<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title></title>
        <description></description>
        <link></link>
        <atom:link href="/feed.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Generalizando la desigualdad de las medias</title>
            <description>&lt;p&gt;La &lt;a href=&quot;https://libreim.github.io/blog/2014/04/12/desigualdad-medias/&quot;&gt;desigualdad de las medias&lt;/a&gt; es una herramienta muy útil para resolver problemas de mínimos o máximos. En este post generalizamos los conceptos de media aritmética y geométrica y esta desigualdad en espacios de medida arbitrarios, obteniendo la desigualdad clásica como caso particular.&lt;/p&gt;

&lt;h2 id=&quot;espacios-de-medida&quot;&gt;Espacios de medida&lt;/h2&gt;

&lt;p&gt;Los espacios de medida son espacios en los que asignamos un valor numérico a cada subconjunto (que interpretamos como una generalización del concepto de volumen o área). Para este post nos restringimos a medidas que asignan valores no negativos (o infinito) a los subconjuntos, pero el concepto &lt;a href=&quot;https://ncatlab.org/nlab/show/measure+space#generalizations&quot;&gt;puede generalizarse más&lt;/a&gt;. La propiedad básica de una medida es que es aditiva cuando los conjuntos son disjuntos (esto es, si dividimos un conjunto en dos partes disjuntas y sumamos los volúmenes individuales debemos obtener el volumen total).&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Definición 1&lt;/dt&gt;
  &lt;dd&gt;Una &lt;strong&gt;medida&lt;/strong&gt; sobre una clase de conjuntos &lt;script type=&quot;math/tex&quot;&gt;\mathcal{A}&lt;/script&gt; es una función &lt;script type=&quot;math/tex&quot;&gt;\mu:\mathcal{A} \to [0,+\infty]&lt;/script&gt; que cumple:&lt;/dd&gt;
  &lt;dd&gt;&lt;/dd&gt;
  &lt;dd&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Conjunto vacío nulo&lt;/strong&gt;: &lt;script type=&quot;math/tex&quot;&gt;\mu(\varnothing) = 0&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/dd&gt;
  &lt;dd&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Aditividad numerable&lt;/strong&gt;: Dada una colección numerable &lt;script type=&quot;math/tex&quot;&gt;\{E_n\}_{n \in \mathbb{N}} \subseteq \mathcal{A}&lt;/script&gt; de&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/dd&gt;
  &lt;dd&gt;subconjuntos disjuntos dos a dos se tiene que:&lt;/dd&gt;
  &lt;dd&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mu\left(\bigcup_{n \in \mathbb{N}} E_n\right) = \sum_{n\in\mathbb{N}} \mu(E_n)&lt;/script&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Por razones técnicas es posible que no podamos asignar un valor a todos los subconjuntos del espacio total (pueden existir &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-measurable_set&quot;&gt;conjuntos no medibles&lt;/a&gt;) por lo que debemos restringirnos por tanto a una subclase de conjuntos con una mínima estructura.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Definición 2&lt;/dt&gt;
  &lt;dd&gt;Un &lt;strong&gt;espacio de medida&lt;/strong&gt; es una tripleta &lt;script type=&quot;math/tex&quot;&gt;(X, \mathcal{A}, \mu)&lt;/script&gt; donde:&lt;/dd&gt;
  &lt;dd&gt;&lt;/dd&gt;
  &lt;dd&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;\mathcal{A} \subseteq \mathcal{P}(X)&lt;/script&gt; es un &lt;a href=&quot;https://en.wikipedia.org/wiki/Sigma-algebra&quot;&gt;&lt;em&gt;&lt;script type=&quot;math/tex&quot;&gt;\sigma&lt;/script&gt;-álgebra&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/dd&gt;
  &lt;dd&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;\mu:\mathcal{A} \to [0,+\infty]&lt;/script&gt; es una &lt;em&gt;medida&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Dado que no es el objetivo del post no desarrollamos más aquí estos conceptos o sus propiedades básicas. Para una introducción completa puede leerse &lt;a href=&quot;https://terrytao.wordpress.com/books/an-introduction-to-measure-theory/&quot;&gt;&lt;em&gt;An introduction to measure theory&lt;/em&gt;&lt;/a&gt; de Terence Tao.&lt;/p&gt;

&lt;h3 id=&quot;ejemplos&quot;&gt;Ejemplos&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;El ejemplo más sencillo de medida es la &lt;em&gt;cardinalidad&lt;/em&gt;. Dado un conjunto &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; podemos medir cualquier subconjunto 
suyo (&lt;script type=&quot;math/tex&quot;&gt;\mathcal{A} = \mathcal{P}(X)&lt;/script&gt;) contando su número de elementos. Esto es:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mu(Y) = |Y|&lt;/script&gt;

    &lt;p&gt;Si el número de elementos de &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; es infinito entonces asignamos &lt;script type=&quot;math/tex&quot;&gt;\mu(Y) = \infty&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Los &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_space&quot;&gt;&lt;em&gt;espacios de probabilidad&lt;/em&gt;&lt;/a&gt; son espacios de medida donde &lt;script type=&quot;math/tex&quot;&gt;\mu(X) = 1&lt;/script&gt;. En este caso la medida suele notarse 
con &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt; y es la probabilidad que conocemos.&lt;/li&gt;
  &lt;li&gt;La &lt;a href=&quot;https://en.wikipedia.org/wiki/Lebesgue_measure&quot;&gt;&lt;em&gt;medida de Lebesgue&lt;/em&gt;&lt;/a&gt; da una medida para &lt;script type=&quot;math/tex&quot;&gt;\mathbb{R}^n&lt;/script&gt; que coincide con el concepto de longitud, área, volumen…&lt;/li&gt;
  &lt;li&gt;Dado &lt;script type=&quot;math/tex&quot;&gt;x \in X&lt;/script&gt; la &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_measure&quot;&gt;&lt;em&gt;medida de Dirac&lt;/em&gt;&lt;/a&gt; &lt;script type=&quot;math/tex&quot;&gt;\delta_x&lt;/script&gt; indica si &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; pertenece al conjunto medido: &lt;script type=&quot;math/tex&quot;&gt;\delta_x(A) = 1&lt;/script&gt; si &lt;script type=&quot;math/tex&quot;&gt;x \in A&lt;/script&gt; y &lt;script type=&quot;math/tex&quot;&gt;\delta_x(A) = 0&lt;/script&gt; en otro caso. Este es un caso particular de medida de probabilidad.&lt;/li&gt;
  &lt;li&gt;Cualquier múltiplo de una medida es una medida&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;integral-e-integral-geométrica&quot;&gt;Integral e integral geométrica&lt;/h2&gt;

&lt;p&gt;Dado un espacio de medida &lt;script type=&quot;math/tex&quot;&gt;(M, \mathcal{A}, \mu)&lt;/script&gt; podemos definir un concepto de integral para cualquier &lt;a href=&quot;https://en.wikipedia.org/wiki/Measurable_function&quot;&gt;función medible&lt;/a&gt;. El proceso de construcción consta de los siguientes pasos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;La integral de una función indicadora es la medida del conjunto que indica:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M 1_A \, \mathrm{d}\mu = \mu(A)&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La integral es lineal por tanto la integral de una combinación lineal finita de funciones indicadoras (&lt;a href=&quot;https://en.wikipedia.org/wiki/Simple_function&quot;&gt;función simple&lt;/a&gt;) puede calcularse:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M \sum_n a_n1_{A_n}\, \mathrm{d}\mu = \sum_n a_n\mu(A_n)&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Si &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; es el conjunto de las funciones simples, la integral de una función medible no negativa es:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M f  \, \mathrm{d}\mu = \sup \left\{\int_M s \, \mathrm{d}\mu \; : \; 0 \leq s \leq f, \, s \in S\right\}&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;En el caso de funciones complejas dividimos la función en su parte real e imaginaria y cada una de estas en su 
parte positiva y negativa y calculamos las integrales por separado. En el caso de que obtengamos valores finitos y 
no haya indeterminaciones (esto es, la función sea integrable) hemos definido la integral&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La integral así definida es lineal y creciente y además verifica la siguiente propiedad: dado un subconjunto numerable &lt;script type=&quot;math/tex&quot;&gt;\{E_n\}_{n \in \mathbb{N}} \subseteq \mathcal{A}&lt;/script&gt; de subconjuntos disjuntos dos a dos se tiene que&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{\bigcup_{n} E_n} f \, \mathrm{d}\mu = \sum_{n} \int_{E_n} f\, \mathrm{d}\mu&lt;/script&gt;

&lt;p&gt;Este concepto de integral puede interpretarse informalmente como una “suma” de los valores que alcanza la función. Si tenemos una función positiva podemos hacer el mismo proceso haciendo el “producto” de los valores, dando lugar a la &lt;a href=&quot;https://en.wikipedia.org/wiki/Product_integral#Type_II&quot;&gt;integral geométrica&lt;/a&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\prod_M f(x)^{\mathrm{d}\mu} = \exp\left(\int_M \log f(x) \, \mathrm{d}\mu\right)&lt;/script&gt;

&lt;h3 id=&quot;ejemplos-1&quot;&gt;Ejemplos&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Las integrales respecto de la &lt;em&gt;cardinalidad&lt;/em&gt; sobre un conjunto finito corresponden con la suma y el producto de 
los valores de la función. Esto es, si &lt;script type=&quot;math/tex&quot;&gt;I=\{1,\dots,n\}&lt;/script&gt; y &lt;script type=&quot;math/tex&quot;&gt;f: I \to \mathbb{R}^+&lt;/script&gt; sus integrales son:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_I f \, \mathrm{d}\mu = \sum_{i=1}^{n} f(i)&lt;/script&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\prod_I f^{\mathrm{d}\mu} = \prod_{i=1}^{n} f(i)&lt;/script&gt;

    &lt;p&gt;Si el número de elementos es infinito entonces la integral se corresponde con el supremo de las sumas o productos 
parciales.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;En un espacio de probabilidad &lt;script type=&quot;math/tex&quot;&gt;(\Omega, \mathcal{E}, P)&lt;/script&gt; dada una variable aleatoria integrable se tiene que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_\Omega X \,\mathrm{d}P = \mathbb{E}[X]&lt;/script&gt;

    &lt;p&gt;El caso geométrico se llama integral geométrica y cumple propiedades análogas a la esperanza. Por ejemplo, existe 
una versión de la ley de los grandes números geométrica: si &lt;script type=&quot;math/tex&quot;&gt;X_i&lt;/script&gt; es una sucesión de variables i.i.d. se tiene que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\sqrt[n]{X_1\cdots X_n} \overset{P}{\to} \prod_\Omega X^{\mathrm{d}P}&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La integral dada por la medida de Lebesgue es la integral usual en &lt;script type=&quot;math/tex&quot;&gt;\mathbb{R}^n&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La integral y la integral geométrica de la medida de Dirac coinciden. Si &lt;script type=&quot;math/tex&quot;&gt;x \in A&lt;/script&gt; y tenemos una función 
&lt;script type=&quot;math/tex&quot;&gt;f:A \to \mathbb{R}^+&lt;/script&gt; tenemos que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_I f \, \mathrm{d}\delta_x = \prod_I f^{\mathrm{d}\delta_x} = f(x)&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dada una medida &lt;script type=&quot;math/tex&quot;&gt;\mu&lt;/script&gt; y un múltiplo suyo &lt;script type=&quot;math/tex&quot;&gt;\lambda\mu&lt;/script&gt; tenemos que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M f \,\mathrm{d}\lambda\mu = \lambda\int_M f \,\mathrm{d}\mu&lt;/script&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\prod_M f^{\mathrm{d}\lambda\mu} = \left(\prod_M f^{\mathrm{d}\mu}\right)^\lambda&lt;/script&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;medias-de-una-función&quot;&gt;Medias de una función&lt;/h2&gt;

&lt;p&gt;A partir del concepto de integral podemos definir la &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean_of_a_function&quot;&gt;media aritmética&lt;/a&gt; y geométrica de una función integrable, que generalizan las medias ya conocidas en el caso discreto. Aunque no las tratamos aquí la media armónica y la media cuadrática también pueden generalizarse.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Definición 3&lt;/dt&gt;
  &lt;dd&gt;Dada un espacio de medida &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; con medida total finita y una función integrable &lt;script type=&quot;math/tex&quot;&gt;f:M \to \mathbb{C}&lt;/script&gt;, la &lt;strong&gt;media aritmética&lt;/strong&gt; de &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; es:&lt;/dd&gt;
  &lt;dd&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;A(f) = \frac{1}{\mu(M)}\int_M f(x)\;\mathrm{d}\mu&lt;/script&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Análogamente podemos hacerlo para el caso geométrico:&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Definición 4&lt;/dt&gt;
  &lt;dd&gt;En la situación anterior, si &lt;script type=&quot;math/tex&quot;&gt;f(M) \subseteq \mathbb{R}^+&lt;/script&gt; la &lt;strong&gt;media geométrica&lt;/strong&gt; de &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; es:&lt;/dd&gt;
  &lt;dd&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;G(f) = \left(\prod_M f(x)^{\mathrm{d}\mu}\right)^{\frac{1}{\mu(M)}}&lt;/script&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;indicamos la medida como subíndice en caso de que sea necesario.&lt;/p&gt;

&lt;h3 id=&quot;algunas-propiedades&quot;&gt;Algunas propiedades&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Es fácil ver que la media aritmética de una variable aleatoria coincide con su esperanza. Este hecho tiene una 
versión recíproca. Si &lt;script type=&quot;math/tex&quot;&gt;(M,\mathcal{A},\mu)&lt;/script&gt; es una medida tal que &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\mu(M) &lt; \infty %]]&gt;&lt;/script&gt; podemos construir un espacio de probabilidad con la probabilidad&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mu(A) = \frac{\mu(A)}{\mu(M)}&lt;/script&gt;

    &lt;p&gt;En este caso tenemos que si tomamos &lt;script type=&quot;math/tex&quot;&gt;f: M \to \mathbb{C}&lt;/script&gt; se tiene que&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;A(f) = \mathbb{E}_{P_\mu}[X]&lt;/script&gt;

    &lt;p&gt;Esto nos da una interpretación probabilística de la media aritmética de una función; por ejemplo si 
&lt;script type=&quot;math/tex&quot;&gt;f:[a,b] \to \mathbb{C}&lt;/script&gt; es una función integrable tenemos que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;A(f) = \frac{1}{b-a} \int_a^b f(x)\,\mathrm{d}x = \mathbb{E}[f(X)]&lt;/script&gt;

    &lt;p&gt;donde &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; sigue una distribución uniforme sobre &lt;script type=&quot;math/tex&quot;&gt;[a,b]&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;En el caso de funciones continuas reales de variable real podemos hallar una consecuencia sencilla del 
teorema del valor medio. Dada &lt;script type=&quot;math/tex&quot;&gt;f: [a,b] \to \mathbb{R}&lt;/script&gt; continua existe un punto &lt;script type=&quot;math/tex&quot;&gt;\xi \in [a,b]&lt;/script&gt; tal que &lt;script type=&quot;math/tex&quot;&gt;A(f) = f(\xi)&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La media aritmética de una función está acotada por las cotas de la función. Por ejemplo, si tenemos un compacto 
&lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; y una función continua &lt;script type=&quot;math/tex&quot;&gt;f:M \to \mathbb{R}&lt;/script&gt; se cumple que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{x \in M} f(x) \leq A(f) \leq \max_{x \in M} f(x)&lt;/script&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;la-desigualdad-de-las-medias&quot;&gt;La desigualdad de las medias&lt;/h2&gt;

&lt;p&gt;Sean &lt;script type=&quot;math/tex&quot;&gt;x_1, \dots, x_n&lt;/script&gt; valores positivos. La &lt;a href=&quot;https://en.wikipedia.org/wiki/Inequality_of_arithmetic_and_geometric_means&quot;&gt;desigualdad de las medias aritmética-geométrica&lt;/a&gt; nos indica que se verifica:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac1n\sum_i x_i \geq \left(\prod_i x_i\right)^\frac1n&lt;/script&gt;

&lt;p&gt;En el caso de que &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; tome valores reales positivos podemos generalizar esta desigualdad al caso general, esto es:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A(f) \geq G(f)&lt;/script&gt;

&lt;p&gt;para cualquier &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; integrable en un espacio de medida. Esta desigualdad es una consecuencia de la &lt;a href=&quot;https://en.wikipedia.org/wiki/Jensen's_inequality#Measure-theoretic_and_probabilistic_form&quot;&gt;desigualdad de Jensen&lt;/a&gt;, que nos indica:&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Desigualdad de Jensen&lt;/dt&gt;
  &lt;dd&gt;Sea &lt;script type=&quot;math/tex&quot;&gt;(M, \mathcal{A}, \mu)&lt;/script&gt; un espacio de medida, &lt;script type=&quot;math/tex&quot;&gt;f:M \to \mathbb{R}&lt;/script&gt; y &lt;script type=&quot;math/tex&quot;&gt;\varphi: \mathbb{R} \to \mathbb{R}&lt;/script&gt; una&lt;/dd&gt;
  &lt;dd&gt;función convexa. Entonces:&lt;/dd&gt;
  &lt;dd&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\varphi\left(\frac{1}{\mu(M)} \int_M f \, \mathrm{d}\mu \right) \leq \frac{1}{\mu(M)} \int_M \varphi \circ f \,\mathrm{d}\mu&lt;/script&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Dada &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; basta aplicar la desigualdad con &lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt; la función exponencial sobre la media aritmética de &lt;script type=&quot;math/tex&quot;&gt;\log f&lt;/script&gt; para obtener el resultado. En el caso de la medida de Lebesgue la desigualdad queda:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{\mu(M)} \int_M f(x) \, \mathrm{d}x \geq \left(\prod_M f(x)^{\mathrm{d}x}\right)^{\frac{1}{\mu(M)}}&lt;/script&gt;

&lt;h3 id=&quot;medias-ponderadas&quot;&gt;Medias ponderadas&lt;/h3&gt;

&lt;p&gt;Dado un espacio de medida &lt;script type=&quot;math/tex&quot;&gt;(\Omega, \mathcal{A}, \mu)&lt;/script&gt; podemos utilizar una función integrable &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; para construir otra medida &lt;script type=&quot;math/tex&quot;&gt;\mu_g&lt;/script&gt; sobre el mismo espacio, que podemos interpretar como una medida ponderada por &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mu_g(A) = \int_A g \, \mathrm{d}\mu&lt;/script&gt;

&lt;p&gt;En este caso la integral de una función &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; puede calcularse como:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M f \,\mathrm{d}\mu_g = \int_M fg \,\mathrm{d}\mu&lt;/script&gt;

&lt;p&gt;Utilizando esta medida podemos construir y generalizar medias ponderadas. El caso más común es el uso de una función masa de probabilidad o una función de densidad con las que &lt;a href=&quot;https://en.wikipedia.org/wiki/Radon–Nikodym_theorem&quot;&gt;expresar una distribución&lt;/a&gt; de probabilidad.&lt;/p&gt;

&lt;p&gt;Además podemos obtener otros casos particulares de la desigualdad de las medias. Por ejemplo, en el caso discreto si tomamos una función de pesos &lt;script type=&quot;math/tex&quot;&gt;\omega: I \to \mathbb{R}&lt;/script&gt; tal que &lt;script type=&quot;math/tex&quot;&gt;\sum_{i} \omega(i) = 1&lt;/script&gt; tenemos la desigualdad ponderada de las medias:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^n \omega_ix_i =  A_{\omega}(x) \geq G_{\omega}(x) = \prod_{i=1}^n x_i^{\omega_i}&lt;/script&gt;

&lt;p&gt;En el caso de la medida de Lebesgue (con una función que integra 1) la desigualdad queda:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M \omega(x)f(x) \,\mathrm{d}x \geq \prod_M f(x)^{\omega(x)\,\mathrm{d}x}&lt;/script&gt;

</description>
            <pubDate>Sat, 03 Mar 2018 00:00:00 +0000</pubDate>
            <link>/blog/2018/03/03/medias/</link>
            <guid isPermaLink="true">/blog/2018/03/03/medias/</guid>
        </item>
        
        <item>
            <title>Generalizando la desigualdad de las medias</title>
            <description>&lt;p&gt;La &lt;a href=&quot;https://libreim.github.io/blog/2014/04/12/desigualdad-medias/&quot;&gt;desigualdad de las medias&lt;/a&gt; es una herramienta muy útil para resolver problemas de mínimos o máximos. En este post generalizamos los conceptos de media aritmética y geométrica y esta desigualdad en espacios de medida arbitrarios, obteniendo la desigualdad clásica como caso particular.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;espacios-de-medida&quot;&gt;Espacios de medida&lt;/h2&gt;

&lt;p&gt;Los espacios de medida son espacios en los que asignamos un valor numérico a cada subconjunto (que interpretamos como una generalización del concepto de volumen o área). Para este post nos restringimos a medidas que asignan valores no negativos (o infinito) a los subconjuntos, pero el concepto &lt;a href=&quot;https://ncatlab.org/nlab/show/measure+space#generalizations&quot;&gt;puede generalizarse más&lt;/a&gt;. La propiedad básica de una medida es que es aditiva cuando los conjuntos son disjuntos (esto es, si dividimos un conjunto en dos partes disjuntas y sumamos los volúmenes individuales debemos obtener el volumen total).&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Definición 1&lt;/dt&gt;
  &lt;dd&gt;Una &lt;strong&gt;medida&lt;/strong&gt; sobre una clase de conjuntos &lt;script type=&quot;math/tex&quot;&gt;\mathcal{A}&lt;/script&gt; es una función &lt;script type=&quot;math/tex&quot;&gt;\mu:\mathcal{A} \to [0,+\infty]&lt;/script&gt; que cumple:&lt;/dd&gt;
  &lt;dd&gt;&lt;/dd&gt;
  &lt;dd&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Conjunto vacío nulo&lt;/strong&gt;: &lt;script type=&quot;math/tex&quot;&gt;\mu(\varnothing) = 0&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/dd&gt;
  &lt;dd&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;Aditividad numerable&lt;/strong&gt;: Dada una colección numerable &lt;script type=&quot;math/tex&quot;&gt;\{E_n\}_{n \in \mathbb{N}} \subseteq \mathcal{A}&lt;/script&gt; de&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/dd&gt;
  &lt;dd&gt;subconjuntos disjuntos dos a dos se tiene que:&lt;/dd&gt;
  &lt;dd&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mu\left(\bigcup_{n \in \mathbb{N}} E_n\right) = \sum_{n\in\mathbb{N}} \mu(E_n)&lt;/script&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Por razones técnicas es posible que no podamos asignar un valor a todos los subconjuntos del espacio total (pueden existir &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-measurable_set&quot;&gt;conjuntos no medibles&lt;/a&gt;) por lo que debemos restringirnos por tanto a una subclase de conjuntos con una mínima estructura.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Definición 2&lt;/dt&gt;
  &lt;dd&gt;Un &lt;strong&gt;espacio de medida&lt;/strong&gt; es una tripleta &lt;script type=&quot;math/tex&quot;&gt;(X, \mathcal{A}, \mu)&lt;/script&gt; donde:&lt;/dd&gt;
  &lt;dd&gt;&lt;/dd&gt;
  &lt;dd&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;\mathcal{A} \subseteq \mathcal{P}(X)&lt;/script&gt; es un &lt;a href=&quot;https://en.wikipedia.org/wiki/Sigma-algebra&quot;&gt;&lt;em&gt;&lt;script type=&quot;math/tex&quot;&gt;\sigma&lt;/script&gt;-álgebra&lt;/em&gt;&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/dd&gt;
  &lt;dd&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;\mu:\mathcal{A} \to [0,+\infty]&lt;/script&gt; es una &lt;em&gt;medida&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Dado que no es el objetivo del post no desarrollamos más aquí estos conceptos o sus propiedades básicas. Para una introducción completa puede leerse &lt;a href=&quot;https://terrytao.wordpress.com/books/an-introduction-to-measure-theory/&quot;&gt;&lt;em&gt;An introduction to measure theory&lt;/em&gt;&lt;/a&gt; de Terence Tao.&lt;/p&gt;

&lt;h3 id=&quot;ejemplos&quot;&gt;Ejemplos&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;El ejemplo más sencillo de medida es la &lt;em&gt;cardinalidad&lt;/em&gt;. Dado un conjunto &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; podemos medir cualquier subconjunto 
suyo (&lt;script type=&quot;math/tex&quot;&gt;\mathcal{A} = \mathcal{P}(X)&lt;/script&gt;) contando su número de elementos. Esto es:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mu(Y) = |Y|&lt;/script&gt;

    &lt;p&gt;Si el número de elementos de &lt;script type=&quot;math/tex&quot;&gt;Y&lt;/script&gt; es infinito entonces asignamos &lt;script type=&quot;math/tex&quot;&gt;\mu(Y) = \infty&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Los &lt;a href=&quot;https://en.wikipedia.org/wiki/Probability_space&quot;&gt;&lt;em&gt;espacios de probabilidad&lt;/em&gt;&lt;/a&gt; son espacios de medida donde &lt;script type=&quot;math/tex&quot;&gt;\mu(X) = 1&lt;/script&gt;. En este caso la medida suele notarse 
con &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt; y es la probabilidad que conocemos.&lt;/li&gt;
  &lt;li&gt;La &lt;a href=&quot;https://en.wikipedia.org/wiki/Lebesgue_measure&quot;&gt;&lt;em&gt;medida de Lebesgue&lt;/em&gt;&lt;/a&gt; da una medida para &lt;script type=&quot;math/tex&quot;&gt;\mathbb{R}^n&lt;/script&gt; que coincide con el concepto de longitud, área, volumen…&lt;/li&gt;
  &lt;li&gt;Dado &lt;script type=&quot;math/tex&quot;&gt;x \in X&lt;/script&gt; la &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirac_measure&quot;&gt;&lt;em&gt;medida de Dirac&lt;/em&gt;&lt;/a&gt; &lt;script type=&quot;math/tex&quot;&gt;\delta_x&lt;/script&gt; indica si &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; pertenece al conjunto medido: &lt;script type=&quot;math/tex&quot;&gt;\delta_x(A) = 1&lt;/script&gt; si &lt;script type=&quot;math/tex&quot;&gt;x \in A&lt;/script&gt; y &lt;script type=&quot;math/tex&quot;&gt;\delta_x(A) = 0&lt;/script&gt; en otro caso. Este es un caso particular de medida de probabilidad.&lt;/li&gt;
  &lt;li&gt;Cualquier múltiplo de una medida es una medida&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;integral-e-integral-geométrica&quot;&gt;Integral e integral geométrica&lt;/h2&gt;

&lt;p&gt;Dado un espacio de medida &lt;script type=&quot;math/tex&quot;&gt;(M, \mathcal{A}, \mu)&lt;/script&gt; podemos definir un concepto de integral para cualquier &lt;a href=&quot;https://en.wikipedia.org/wiki/Measurable_function&quot;&gt;función medible&lt;/a&gt;. El proceso de construcción consta de los siguientes pasos:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;La integral de una función indicadora es la medida del conjunto que indica:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M 1_A \, \mathrm{d}\mu = \mu(A)&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La integral es lineal por tanto la integral de una combinación lineal finita de funciones indicadoras (&lt;a href=&quot;https://en.wikipedia.org/wiki/Simple_function&quot;&gt;función simple&lt;/a&gt;) puede calcularse:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M \sum_n a_n1_{A_n}\, \mathrm{d}\mu = \sum_n a_n\mu(A_n)&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Si &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; es el conjunto de las funciones simples, la integral de una función medible no negativa es:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M f  \, \mathrm{d}\mu = \sup \left\{\int_M s \, \mathrm{d}\mu \; : \; 0 \leq s \leq f, \, s \in S\right\}&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;En el caso de funciones complejas dividimos la función en su parte real e imaginaria y cada una de estas en su 
parte positiva y negativa y calculamos las integrales por separado. En el caso de que obtengamos valores finitos y 
no haya indeterminaciones (esto es, la función sea integrable) hemos definido la integral&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La integral así definida es lineal y creciente y además verifica la siguiente propiedad: dado un subconjunto numerable &lt;script type=&quot;math/tex&quot;&gt;\{E_n\}_{n \in \mathbb{N}} \subseteq \mathcal{A}&lt;/script&gt; de subconjuntos disjuntos dos a dos se tiene que&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_{\bigcup_{n} E_n} f \, \mathrm{d}\mu = \sum_{n} \int_{E_n} f\, \mathrm{d}\mu&lt;/script&gt;

&lt;p&gt;Este concepto de integral puede interpretarse informalmente como una “suma” de los valores que alcanza la función. Si tenemos una función positiva podemos hacer el mismo proceso haciendo el “producto” de los valores, dando lugar a la &lt;a href=&quot;https://en.wikipedia.org/wiki/Product_integral#Type_II&quot;&gt;integral geométrica&lt;/a&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\prod_M f(x)^{\mathrm{d}\mu} = \exp\left(\int_M \log f(x) \, \mathrm{d}\mu\right)&lt;/script&gt;

&lt;h3 id=&quot;ejemplos-1&quot;&gt;Ejemplos&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Las integrales respecto de la &lt;em&gt;cardinalidad&lt;/em&gt; sobre un conjunto finito corresponden con la suma y el producto de 
los valores de la función. Esto es, si &lt;script type=&quot;math/tex&quot;&gt;I=\{1,\dots,n\}&lt;/script&gt; y &lt;script type=&quot;math/tex&quot;&gt;f: I \to \mathbb{R}^+&lt;/script&gt; sus integrales son:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_I f \, \mathrm{d}\mu = \sum_{i=1}^{n} f(i)&lt;/script&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\prod_I f^{\mathrm{d}\mu} = \prod_{i=1}^{n} f(i)&lt;/script&gt;

    &lt;p&gt;Si el número de elementos es infinito entonces la integral se corresponde con el supremo de las sumas o productos 
parciales.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;En un espacio de probabilidad &lt;script type=&quot;math/tex&quot;&gt;(\Omega, \mathcal{E}, P)&lt;/script&gt; dada una variable aleatoria integrable se tiene que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_\Omega X \,\mathrm{d}P = \mathbb{E}[X]&lt;/script&gt;

    &lt;p&gt;El caso geométrico se llama integral geométrica y cumple propiedades análogas a la esperanza. Por ejemplo, existe 
una versión de la ley de los grandes números geométrica: si &lt;script type=&quot;math/tex&quot;&gt;X_i&lt;/script&gt; es una sucesión de variables i.i.d. se tiene que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\sqrt[n]{X_1\cdots X_n} \overset{P}{\to} \prod_\Omega X^{\mathrm{d}P}&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La integral dada por la medida de Lebesgue es la integral usual en &lt;script type=&quot;math/tex&quot;&gt;\mathbb{R}^n&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La integral y la integral geométrica de la medida de Dirac coinciden. Si &lt;script type=&quot;math/tex&quot;&gt;x \in A&lt;/script&gt; y tenemos una función 
&lt;script type=&quot;math/tex&quot;&gt;f:A \to \mathbb{R}^+&lt;/script&gt; tenemos que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_A f \, \mathrm{d}\delta_x = \prod_A f^{\mathrm{d}\delta_x} = f(x)&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dada una medida &lt;script type=&quot;math/tex&quot;&gt;\mu&lt;/script&gt; y un múltiplo suyo &lt;script type=&quot;math/tex&quot;&gt;\lambda\mu&lt;/script&gt; tenemos que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M f \,\mathrm{d}\lambda\mu = \lambda\int_M f \,\mathrm{d}\mu&lt;/script&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\prod_M f^{\mathrm{d}\lambda\mu} = \left(\prod_M f^{\mathrm{d}\mu}\right)^\lambda&lt;/script&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;medias-de-una-función&quot;&gt;Medias de una función&lt;/h2&gt;

&lt;p&gt;A partir del concepto de integral podemos definir la &lt;a href=&quot;https://en.wikipedia.org/wiki/Mean_of_a_function&quot;&gt;media aritmética&lt;/a&gt; y geométrica de una función integrable, que generalizan las medias ya conocidas en el caso discreto. Aunque no las tratamos aquí la media armónica y la media cuadrática también pueden generalizarse.&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Definición 3&lt;/dt&gt;
  &lt;dd&gt;Dada un espacio de medida &lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; con medida total finita y una función integrable &lt;script type=&quot;math/tex&quot;&gt;f:M \to \mathbb{C}&lt;/script&gt;, la &lt;strong&gt;media aritmética&lt;/strong&gt; de &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; es:&lt;/dd&gt;
  &lt;dd&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;A(f) = \frac{1}{\mu(M)}\int_M f(x)\;\mathrm{d}\mu&lt;/script&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Análogamente podemos hacerlo para el caso geométrico:&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Definición 4&lt;/dt&gt;
  &lt;dd&gt;En la situación anterior, si &lt;script type=&quot;math/tex&quot;&gt;f(M) \subseteq \mathbb{R}^+&lt;/script&gt; la &lt;strong&gt;media geométrica&lt;/strong&gt; de &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; es:&lt;/dd&gt;
  &lt;dd&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;G(f) = \left(\prod_M f(x)^{\mathrm{d}\mu}\right)^{\frac{1}{\mu(M)}}&lt;/script&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;indicamos la medida como subíndice en caso de que sea necesario.&lt;/p&gt;

&lt;h3 id=&quot;algunas-propiedades&quot;&gt;Algunas propiedades&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Es fácil ver que la media aritmética de una variable aleatoria coincide con su esperanza. Este hecho tiene una 
versión recíproca. Si &lt;script type=&quot;math/tex&quot;&gt;(M,\mathcal{A},\mu)&lt;/script&gt; es una medida tal que &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\mu(M) &lt; \infty %]]&gt;&lt;/script&gt; podemos construir un espacio de probabilidad con la probabilidad&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;P_\mu(A) = \frac{\mu(A)}{\mu(M)}&lt;/script&gt;

    &lt;p&gt;En este caso tenemos que si tomamos &lt;script type=&quot;math/tex&quot;&gt;f: M \to \mathbb{C}&lt;/script&gt; se tiene que&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;A(f) = \mathbb{E}_{P_\mu}[X]&lt;/script&gt;

    &lt;p&gt;Esto nos da una interpretación probabilística de la media aritmética de una función; por ejemplo si 
&lt;script type=&quot;math/tex&quot;&gt;f:[a,b] \to \mathbb{C}&lt;/script&gt; es una función integrable tenemos que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;A(f) = \frac{1}{b-a} \int_a^b f(x)\,\mathrm{d}x = \mathbb{E}[f(X)]&lt;/script&gt;

    &lt;p&gt;donde &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; sigue una distribución uniforme sobre &lt;script type=&quot;math/tex&quot;&gt;[a,b]&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;En el caso de funciones continuas reales de variable real podemos hallar una consecuencia sencilla del 
teorema del valor medio. Dada &lt;script type=&quot;math/tex&quot;&gt;f: [a,b] \to \mathbb{R}&lt;/script&gt; continua existe un punto &lt;script type=&quot;math/tex&quot;&gt;\xi \in [a,b]&lt;/script&gt; tal que &lt;script type=&quot;math/tex&quot;&gt;A(f) = f(\xi)&lt;/script&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;La media aritmética de una función está acotada por las cotas de la función. Por ejemplo, si tenemos un compacto 
&lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; y una función continua &lt;script type=&quot;math/tex&quot;&gt;f:M \to \mathbb{R}&lt;/script&gt; se cumple que:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{x \in M} f(x) \leq A(f) \leq \max_{x \in M} f(x)&lt;/script&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;la-desigualdad-de-las-medias&quot;&gt;La desigualdad de las medias&lt;/h2&gt;

&lt;p&gt;Sean &lt;script type=&quot;math/tex&quot;&gt;x_1, \dots, x_n&lt;/script&gt; valores positivos. La &lt;a href=&quot;https://en.wikipedia.org/wiki/Inequality_of_arithmetic_and_geometric_means&quot;&gt;desigualdad de las medias aritmética-geométrica&lt;/a&gt; nos indica que se verifica:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac1n\sum_i x_i \geq \left(\prod_i x_i\right)^\frac1n&lt;/script&gt;

&lt;p&gt;En el caso de que &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; tome valores reales positivos podemos generalizar esta desigualdad al caso general, esto es:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A(f) \geq G(f)&lt;/script&gt;

&lt;p&gt;para cualquier &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; integrable en un espacio de medida. Esta desigualdad es una consecuencia de la &lt;a href=&quot;https://en.wikipedia.org/wiki/Jensen's_inequality#Measure-theoretic_and_probabilistic_form&quot;&gt;desigualdad de Jensen&lt;/a&gt;, que nos indica:&lt;/p&gt;

&lt;dl&gt;
  &lt;dt&gt;Desigualdad de Jensen&lt;/dt&gt;
  &lt;dd&gt;Sea &lt;script type=&quot;math/tex&quot;&gt;(M, \mathcal{A}, \mu)&lt;/script&gt; un espacio de medida, &lt;script type=&quot;math/tex&quot;&gt;f:M \to \mathbb{R}&lt;/script&gt; y &lt;script type=&quot;math/tex&quot;&gt;\varphi: \mathbb{R} \to \mathbb{R}&lt;/script&gt; una&lt;/dd&gt;
  &lt;dd&gt;función convexa. Entonces:&lt;/dd&gt;
  &lt;dd&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\varphi\left(\frac{1}{\mu(M)} \int_M f \, \mathrm{d}\mu \right) \leq \frac{1}{\mu(M)} \int_M \varphi \circ f \,\mathrm{d}\mu&lt;/script&gt;
  &lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;Dada &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; basta aplicar la desigualdad con &lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt; la función exponencial sobre la media aritmética de &lt;script type=&quot;math/tex&quot;&gt;\log f&lt;/script&gt; para obtener el resultado. En el caso de la medida de Lebesgue la desigualdad queda:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{\mu(M)} \int_M f(x) \, \mathrm{d}x \geq \left(\prod_M f(x)^{\mathrm{d}x}\right)^{\frac{1}{\mu(M)}}&lt;/script&gt;

&lt;h3 id=&quot;medias-ponderadas&quot;&gt;Medias ponderadas&lt;/h3&gt;

&lt;p&gt;Dado un espacio de medida &lt;script type=&quot;math/tex&quot;&gt;(\Omega, \mathcal{A}, \mu)&lt;/script&gt; podemos utilizar una función integrable &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt; para construir otra medida &lt;script type=&quot;math/tex&quot;&gt;\mu_g&lt;/script&gt; sobre el mismo espacio, que podemos interpretar como una medida ponderada por &lt;script type=&quot;math/tex&quot;&gt;g&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mu_g(A) = \int_A g \, \mathrm{d}\mu&lt;/script&gt;

&lt;p&gt;En este caso la integral de una función &lt;script type=&quot;math/tex&quot;&gt;f&lt;/script&gt; puede calcularse como:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M f \,\mathrm{d}\mu_g = \int_M fg \,\mathrm{d}\mu&lt;/script&gt;

&lt;p&gt;Utilizando esta medida podemos construir y generalizar medias ponderadas. El caso más común es el uso de una función masa de probabilidad o una función de densidad con las que &lt;a href=&quot;https://en.wikipedia.org/wiki/Radon–Nikodym_theorem&quot;&gt;expresar una distribución&lt;/a&gt; de probabilidad.&lt;/p&gt;

&lt;p&gt;Además podemos obtener otros casos particulares de la desigualdad de las medias. Por ejemplo, en el caso discreto si tomamos una función de pesos &lt;script type=&quot;math/tex&quot;&gt;\omega: I \to \mathbb{R}&lt;/script&gt; tal que &lt;script type=&quot;math/tex&quot;&gt;\sum_{i} \omega(i) = 1&lt;/script&gt; tenemos la desigualdad ponderada de las medias:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^n \omega_ix_i =  A_{\omega}(x) \geq G_{\omega}(x) = \prod_{i=1}^n x_i^{\omega_i}&lt;/script&gt;

&lt;p&gt;En el caso de la medida de Lebesgue (con una función que integra 1) la desigualdad queda:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\int_M \omega(x)f(x) \,\mathrm{d}x \geq \prod_M f(x)^{\omega(x)\,\mathrm{d}x}&lt;/script&gt;

</description>
            <pubDate>Thu, 01 Mar 2018 00:00:00 +0000</pubDate>
            <link>/blog/2018/03/01/medias/</link>
            <guid isPermaLink="true">/blog/2018/03/01/medias/</guid>
        </item>
        
        <item>
            <title>Recursos sobre cálculo lambda</title>
            <description>&lt;blockquote&gt;
  &lt;p&gt;1936 - Alonzo Church also invents every language that will ever be
but does it better. His lambda calculus is ignored because it is
insufficiently C-like. This criticism occurs in spite of the fact
that C has not yet been invented.&lt;/p&gt;

  &lt;p&gt;– &lt;em&gt;&lt;a href=&quot;http://james-iry.blogspot.com.es/2009/05/brief-incomplete-and-mostly-wrong.html&quot;&gt;A Brief, Incomplete, and Mostly Wrong History of programming languages&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Alonzo Church desarrolló el cálculo lambda en los años 30 como un
sistema formal que capturaba una noción abstracta de función. Este
sistema puede interpretarse a su vez como un modelo de computación
equivalente a las máquinas de Turing.  Refinamientos posteriores
añadieron tipos al lenguaje, que serían la base de una correspondencia
entre modelos de computación y sistemas lógicos.&lt;/p&gt;

&lt;h2 id=&quot;apuntes-generales&quot;&gt;Apuntes generales&lt;/h2&gt;
&lt;p&gt;Pueden encontrarse presentaciones generales sobre el cálculo lambda en:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Peter Selinger, &lt;a href=&quot;http://www.mathstat.dal.ca/~selinger/papers/lambdanotes.pdf&quot;&gt;Lecture notes on the lambda calculus&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Raúl Rojas, &lt;a href=&quot;https://www.utdallas.edu/%7Egupta/courses/apl/lambda.pdf&quot;&gt;A Tutorial Introduction to the Lambda Calculus&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;H.P. Barendregt, The Lambda Calculus, its syntax and semantics.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;p&gt;En particular, hemos publicado &lt;a href=&quot;https://github.com/M42/lambda.notes&quot;&gt;tres capítulos sobre cálculo lambda&lt;/a&gt;
como parte de una serie de notas sobre categorías y computación, y una &lt;a href=&quot;https://m42.github.io/talks/untypedlambda.pdf&quot;&gt;presentación&lt;/a&gt;
sobre las bases del cálculo lambda. Tratan&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cálculo lambda no tipado,&lt;/li&gt;
  &lt;li&gt;cálculo lambda simplemente tipado, y&lt;/li&gt;
  &lt;li&gt;el isomorfismo de Curry-Howard.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;La mayoría de las demostraciones allí expuestas usan &lt;a href=&quot;/blog/2015/03/14/induccion-estructural/&quot;&gt;inducción estructural&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;intérpretes-de-cálculo-lambda&quot;&gt;Intérpretes de cálculo lambda&lt;/h2&gt;
&lt;p&gt;Junto a esas notas, se ofrece un intérprete de cálculo lambda no tipado y
simplemente tipado.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://m42.github.io/mikrokosmos/&quot;&gt;Mikrokosmos&lt;/a&gt;, intérprete de cálculo lambda.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://m42.github.io/mikrokosmos/tutorial.html&quot;&gt;Tutorial de Mikrokosmos&lt;/a&gt;, explicando cómo programar en el cálculo lambda.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/M42/mikrokosmos&quot;&gt;Código fuente&lt;/a&gt;, en Haskell y licenciado bajo GPLv3.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Muchos otros intérpretes de cálculo lambda pueden encontrarse en
Internet, así como tutoriales para escribir un intérprete&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/goldfirere/glambda&quot;&gt;The Glambda interpreter&lt;/a&gt;,
cuyo código sirve como introducción a GADTs en Haskell;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tadeuzagallo.com/blog/writing-a-lambda-calculus-interpreter-in-javascript/&quot;&gt;A λ-calculus interpreter&lt;/a&gt; un
tutorial en Javascript.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;isomorfismo-de-curry-howard&quot;&gt;Isomorfismo de Curry-Howard&lt;/h2&gt;
&lt;p&gt;El isomorfismo de Curry-Howard es una correspondencia profunda entre tipos y lógica que
se manifiesta en correspondencias particulares entre ciertos sistemas de tipos y ciertos
sistemas lógicos. Por ejemplo, el sistema de tipos del &lt;em&gt;cálculo lambda simplemente tipado&lt;/em&gt;
se corresponde con la &lt;em&gt;lógica proposicional intuicionista&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Puede leerse más sobre este isomorfismo en&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://homepages.inf.ed.ac.uk/wadler/papers/propositions-as-types/propositions-as-types.pdf&quot;&gt;Propositions as Types&lt;/a&gt;, de Philip Wadler;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://libreim.github.io/blog/2014/12/04/curry-howard/&quot;&gt;Los apuntes sobre Curry-Howard&lt;/a&gt;, de este mismo blog; y&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://purelytheoretical.com/papers/ATCHC.pdf&quot;&gt;A tutorial on the Curry-Howard Correspondence&lt;/a&gt;, de Darryl McAdams.&lt;/li&gt;
&lt;/ul&gt;

</description>
            <pubDate>Thu, 09 Nov 2017 00:00:00 +0000</pubDate>
            <link>/blog/2017/11/09/calculolambda/</link>
            <guid isPermaLink="true">/blog/2017/11/09/calculolambda/</guid>
        </item>
        
        <item>
            <title>Emacs for lazy people</title>
            <description>&lt;p&gt;Emacs is one of the most powerful, extensible editors out there.
However, learning to use it is not an easy task, and I’m just really
lazy. The following are some packages that I hope will make your life
way easier. And if you already use Emacs, I encourage you to try them
and see if they help you get a more comfortable development environment.&lt;/p&gt;

&lt;p&gt;To add any of these packages to your Emacs configuration, find your 
initialization file (usually &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.emacs&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.emacs.d/init.el&lt;/code&gt;) and
add the snippets there. You will also need to install and enable &lt;code class=&quot;highlighter-rouge&quot;&gt;use-package&lt;/code&gt; 
beforehand (&lt;a href=&quot;http://www.lunaryorn.com/posts/my-emacs-configuration-with-use-package.html&quot;&gt;why?&lt;/a&gt;).&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;smex&quot;&gt;Smex&lt;/h2&gt;

&lt;p&gt;In Emacs we use M-x
(&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;X&lt;/kbd&gt;) to enter any
command without the need for a dedicated keyboard shortcut or menu
entry. By default Emacs doesn’t help much while writing a command, and
it can be challenging to remember many of them, as well as tedious
writing the long ones (&lt;code class=&quot;highlighter-rouge&quot;&gt;package-list-packages&lt;/code&gt; anyone?).
&lt;a href=&quot;https://github.com/nonsequitur/smex/&quot;&gt;Smex&lt;/a&gt; is a M-x enhancement for
Emacs, built on top of Ido, which means it will try to predict and
autocomplete commands as you write them.&lt;/p&gt;

&lt;p&gt;In order to install and enable Smex, add the following code to your
initialization file:&lt;/p&gt;

&lt;div class=&quot;language-common_lisp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;use-package&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;smex&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;:config&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;smex-initialize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;ergoemacs&quot;&gt;Ergoemacs&lt;/h2&gt;

&lt;p&gt;If you’re just starting to use emacs, you may find it difficult to learn
all the new keybindings. If you’re a long-time user, you may have
experienced repetitive strain injury (RSI), also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Emacs#Emacs_pinky&quot;&gt;Emacs
pinky&lt;/a&gt;. Don’t worry,
I’ve got just the solution for you:
&lt;a href=&quot;https://ergoemacs.github.io/index.html&quot;&gt;ergoemacs-mode&lt;/a&gt; is a minor-mode
that sets ergonomic and well-known keybindings for common editing
functions, with the aim of reducing RSI as well as adding some
familiarity to the use of emacs.&lt;/p&gt;

&lt;p&gt;Just as before, add the following code to your initialization file and
restart Emacs to use it:&lt;/p&gt;

&lt;div class=&quot;language-common_lisp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;use-package&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ergoemacs-mode&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;:init&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;setq&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ergoemacs-theme&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;nil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;setq&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ergoemacs-keyboard-layout&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;es&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;:config&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;ergoemacs-mode&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;You can check &lt;a href=&quot;https://ergoemacs.github.io/key-setup.html&quot;&gt;your new keybinding
layout&lt;/a&gt;. Remember that,
after enabling Ergoemacs, the keyboard shortcut that allows you to enter
a custom command becomes
&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;A&lt;/kbd&gt;.&lt;/p&gt;

&lt;h2 id=&quot;which-key&quot;&gt;Which-key&lt;/h2&gt;

&lt;figure class=&quot;fig large&quot;&gt;
  &lt;a href=&quot;/assets/images/blog/emacs-which-key.png&quot; title=&quot;Ver imagen completa&quot;&gt;
    &lt;img src=&quot;/assets/images/blog/emacs-which-key.png&quot; /&gt;
  &lt;/a&gt;
  Which-key interface
&lt;/figure&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/justbur/emacs-which-key&quot;&gt;Which-key&lt;/a&gt; displays the key
bindings following your currently entered incomplete command. That way,
when you can’t remember which key to press, you’ll have a cheat sheet in
a couple of seconds.&lt;/p&gt;

&lt;div class=&quot;language-common_lisp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;use-package&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;which-key&lt;/span&gt;
&lt;span class=&quot;ss&quot;&gt;:config&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;which-key-mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;auto-reload-stuff&quot;&gt;Auto-reload stuff&lt;/h2&gt;

&lt;p&gt;When using version control, files generally change while having them
open in the editor. If this happens, I expect my editor to refresh the
files so that I don’t write on an old version. Emacs doesn’t enable this
behavior by default, rather letting the user decide if they want to
reload files. Instead, we can set it to automatically reload files from
disk when changed via these configuration lines (source: &lt;a href=&quot;http://pragmaticemacs.com/emacs/automatically-revert-buffers/&quot;&gt;Pragmatic
Emacs&lt;/a&gt;):&lt;/p&gt;

&lt;div class=&quot;language-common_lisp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;global-auto-revert-mode&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;add-hook&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;'dired-mode-hook&lt;/span&gt; &lt;span class=&quot;ss&quot;&gt;'auto-revert-mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;note&quot;&gt;The &lt;a href=&quot;https://magit.vc/&quot;&gt;magit&lt;/a&gt; plugin for version control with git does
refresh the files without the need for this configuration (thanks &lt;a href=&quot;https://ncordon.github.io/&quot;&gt;Nacho&lt;/a&gt;
for the remark!).&lt;/p&gt;

&lt;h2 id=&quot;still-want-more&quot;&gt;Still want more?&lt;/h2&gt;

&lt;p&gt;These are the main tools that have eased my way into Emacs. You can check out the rest of my configuration in &lt;a href=&quot;https://github.com/David Charte/dotfiles/tree/master/emacs&quot;&gt;my dotfiles repository&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Fri, 05 May 2017 00:00:00 +0000</pubDate>
            <link>/blog/2017/05/05/emacs-lazy/</link>
            <guid isPermaLink="true">/blog/2017/05/05/emacs-lazy/</guid>
        </item>
        
        <item>
            <title>Introducción a ZFC</title>
            <description>&lt;p&gt;&lt;em&gt;Este post fue &lt;a href=&quot;//libreim.github.io/blog/2017/03/25/zfc/&quot;&gt;publicado originalmente&lt;/a&gt; en el blog de libreim el 25 de marzo de 2017.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;A principios del siglo XX las matemáticas sufrieron una crisis
fundacional: los principios que se consideraban básicos para la
deducción de las teorías matemáticas daban lugar a paradojas y los
matemáticos de la época se embarcaron en la creación de un sistema
axiomático que pudiera formalizar todos los teoremas de la época sin dar
lugar a estas paradojas.&lt;/p&gt;

&lt;p&gt;Una de las posibles soluciones son las teorías axiomáticas de conjuntos,
de entre las cuales la más utilizada actualmente es ZFC (la teoría de
Zermelo-Fraenkel junto con el axioma de elección)&lt;sup id=&quot;fnref:zfc-alternativas&quot;&gt;&lt;a href=&quot;#fn:zfc-alternativas&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;En este artículo exponemos los axiomas de esta teoría y la comparamos
con otras teorías de conjuntos (y de clases). Se incluyen también
algunos ejercicios.&lt;/p&gt;

&lt;!--more--&gt;

&lt;h2 id=&quot;el-lenguaje&quot;&gt;El lenguaje&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;Second order logic is just set theory in disguise - &lt;a href=&quot;https://en.wikipedia.org/wiki/Willard_Van_Orman_Quine&quot;&gt;W.V.O.
Quine&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Para formalizar una teoría axiomática de cualquier tipo necesitamos un
lenguaje en el cual expresar los axiomas, pero el lenguaje natural
&lt;a href=&quot;https://en.wikipedia.org/wiki/Berry_paradox&quot;&gt;produce paradojas&lt;/a&gt;. Para
solucionar este problema utilizaremos un lenguaje lógico.&lt;/p&gt;

&lt;p&gt;Hay muchas otras posibles elecciones con respecto a qué lógica utilizar:
por ejemplo &lt;a href=&quot;https://en.wikipedia.org/wiki/Constructive_set_theory&quot;&gt;algunas
teorías&lt;/a&gt;
axiomáticas de conjuntos utilizan &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-classical_logic&quot;&gt;lógicas no
clásicas&lt;/a&gt;. Podríamos
también considerar las &lt;a href=&quot;https://plato.stanford.edu/entries/logic-higher-order/&quot;&gt;lógicas de orden
superior&lt;/a&gt; pero
por &lt;a href=&quot;http://philosophy.stackexchange.com/a/2618&quot;&gt;razones históricas y
filosóficas&lt;/a&gt; y por sus
propiedades metalógicas formularemos la teoría en lógica de primer
orden.&lt;/p&gt;

&lt;h3 id=&quot;la-lógica-de-primer-orden&quot;&gt;La lógica de primer orden&lt;/h3&gt;

&lt;p&gt;La lógica de primer orden consta de dos tipos de símbolos: los símbolos
lógicos y los no-lógicos, que forman fórmulas a partir de una &lt;a href=&quot;https://en.wikipedia.org/wiki/First-order_logic#Syntax&quot;&gt;serie de
reglas&lt;/a&gt;. No es
el objetivo de este post explicar en detalle la lógica de primer orden y
basta con que seas capaz de leer fórmulas como
&lt;script type=&quot;math/tex&quot;&gt;\forall x \operatorname{Cuervo}(x) \implies \operatorname{Negro}(x)&lt;/script&gt;
(&lt;em&gt;todos los cuervos son negros&lt;/em&gt;) &lt;sup id=&quot;fnref:zfc-cuervos&quot;&gt;&lt;a href=&quot;#fn:zfc-cuervos&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Los símbolos &lt;strong&gt;lógicos&lt;/strong&gt; de nuestra teoría pueden reducirse a una
colección de conectivas lógicas &lt;a href=&quot;https://en.m.wikipedia.org/wiki/Functional_completeness&quot;&gt;funcionalmente
completas&lt;/a&gt;
(cómo mínimo &lt;a href=&quot;https://en.wikipedia.org/wiki/Sheffer_stroke&quot;&gt;la operación
NAND&lt;/a&gt; o más comúnmente la
conjunción, disyunción, negación, implicación y bicondicional) así como
al menos un cuantificador (para todo &lt;script type=&quot;math/tex&quot;&gt;\forall&lt;/script&gt; o existe &lt;script type=&quot;math/tex&quot;&gt;\exists&lt;/script&gt;).
Contamos además con una cantidad infinita de variables (basta con una
cantidad numerable) para escribir nuestras fórmulas.&lt;/p&gt;

&lt;p&gt;Contaremos además como único símbolo &lt;strong&gt;no-lógico&lt;/strong&gt; a la relación de
pertenencia &lt;script type=&quot;math/tex&quot;&gt;\in(\cdot,\cdot)&lt;/script&gt; que escribiremos &lt;script type=&quot;math/tex&quot;&gt;A \in B&lt;/script&gt; y leemos &lt;em&gt;A
pertenece a B&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Nuestra lógica también incluye el símbolo de igualdad &lt;script type=&quot;math/tex&quot;&gt;=&lt;/script&gt; y &lt;a href=&quot;https://en.wikipedia.org/wiki/First-order_logic#Equality_and_its_axioms&quot;&gt;sus
axiomas&lt;/a&gt;,
que incluimos a continuación por completitud. Los 3 primeros axiomas nos
indican que la igualdad es una &lt;a href=&quot;https://en.wikipedia.org/wiki/Equivalence_relation&quot;&gt;relación de
equivalencia&lt;/a&gt;. El
último es un esquema de axioma (una colección infinita de axiomas que
depende de una fórmula) que caracteriza la igualdad (conocido como
&lt;a href=&quot;https://en.wikipedia.org/wiki/Identity_of_indiscernibles&quot;&gt;&lt;em&gt;identidad de los
indiscernibles&lt;/em&gt;&lt;/a&gt;).&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;Reflexividad&lt;/strong&gt; &lt;script type=&quot;math/tex&quot;&gt;\forall x \; x = x&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Simetría&lt;/strong&gt; &lt;script type=&quot;math/tex&quot;&gt;\forall x \forall y \;  x = y \implies y = x&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Transitividad&lt;/strong&gt;
&lt;script type=&quot;math/tex&quot;&gt;\forall x \forall y \forall z \; x = y \wedge y = z \implies x = z&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Sustitución&lt;/strong&gt; Si &lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt; es una fórmula y &lt;script type=&quot;math/tex&quot;&gt;\varphi'&lt;/script&gt; es la
fórmula que resulta de sustituir todas las ocurrencias libres de &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;
por &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; se verifica:
&lt;script type=&quot;math/tex&quot;&gt;\forall x \forall y  \; x = y \implies (\varphi \implies \varphi')&lt;/script&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;una-nota-sobre-los-cuantificadores&quot;&gt;Una nota sobre los cuantificadores&lt;/h4&gt;

&lt;p&gt;Cuando se escriben fórmulas matemáticas habitualmente omitimos los cuantificadores o utilizamos
&lt;a href=&quot;https://en.wikipedia.org/wiki/Bounded_quantifier&quot;&gt;&lt;em&gt;cuantificadores
delimitados&lt;/em&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \in A \; \varphi(x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \in A \; \varphi(x)&lt;/script&gt;

&lt;p&gt;que leemos &lt;em&gt;para todo&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; &lt;em&gt;en&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; &lt;em&gt;se verifica&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\varphi(x)&lt;/script&gt; y &lt;em&gt;existe
un&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; &lt;em&gt;en&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; &lt;em&gt;tal que&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\varphi(x)&lt;/script&gt; respectivamente.&lt;/p&gt;

&lt;p&gt;En los axiomas de la teoría de conjuntos sin embargo los cuantificadores
no están delimitados, por lo que debemos expresarlo con una fórmula
equivalente:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \; x \in A \implies \varphi(x)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x \; x \in A \wedge \varphi(x)&lt;/script&gt;

&lt;p&gt;es decir &lt;em&gt;para todo &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;, si &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; pertenece a &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; entonces &lt;script type=&quot;math/tex&quot;&gt;\varphi(x)&lt;/script&gt;&lt;/em&gt; y
&lt;em&gt;existe un &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; tal que &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; pertenece a &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; y &lt;script type=&quot;math/tex&quot;&gt;\varphi(x)&lt;/script&gt;&lt;/em&gt;. En este caso
&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; es ahora cualquier conjunto.&lt;sup id=&quot;fnref:zfc-dominio&quot;&gt;&lt;a href=&quot;#fn:zfc-dominio&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;el-dominio-de-discurso&quot;&gt;El dominio de discurso&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;In every discourse, whether of the mind conversing with its own
thoughts, or of the individual in his intercourse with others, there
is an assumed or expressed limit within which the subjects of its
operation are confined. - Boole, 1854&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Las matemáticas tratan de objetos muy dispares como pueden ser los
números, las funciones, los espacios topológicos, las máquinas de Turing
o las categorías. Una teoría fundacional debería ser capaz de expresar
todos estos objetos utilizando las mismas piezas. En algunos casos la
transformación a conjuntos es clara (los espacios topológicos o las
máquinas de Turing suelen definirse de forma explícita como conjuntos)
pero en otros casos (los números o las funciones) esa transformación no
suele realizarse de forma explícita cuando trabajamos con estos. ¿Es
posible expresar cualquier objeto matemático en forma de conjuntos o
necesitamos además otros tipos de objetos?&lt;/p&gt;

&lt;p&gt;En esta sección realizamos construcciones explícitas de estos objetos
matemáticos y discutimos los límites de ZFC para describir todas las
matemáticas.&lt;/p&gt;

&lt;h3 id=&quot;los-números-son-conjuntos&quot;&gt;Los números son conjuntos&lt;/h3&gt;

&lt;p&gt;Algunas teorías como
&lt;a href=&quot;https://en.wikipedia.org/wiki/New_Foundations&quot;&gt;NFU&lt;/a&gt; o
&lt;a href=&quot;https://en.wikipedia.org/wiki/Kripke%E2%80%93Platek_set_theory_with_urelements&quot;&gt;KPU&lt;/a&gt;
admiten &lt;em&gt;urelementos&lt;/em&gt;: elementos que &lt;strong&gt;no&lt;/strong&gt; son conjuntos pero
pueden ser elementos de conjuntos (esto es, sólo pueden aparecer en el
lado izquierdo de &lt;script type=&quot;math/tex&quot;&gt;\in&lt;/script&gt;) y así lo hacía la &lt;a href=&quot;https://en.wikipedia.org/wiki/Zermelo_set_theory&quot;&gt;teoría de
Zermelo&lt;/a&gt; de 1908 en la
que se basa ZFC. Esta podría ser una opción para incluir los números en
nuestra teoría, sin embargo las matemáticas pueden basarse
exclusivamente en &lt;em&gt;conjuntos hereditarios&lt;/em&gt;&lt;sup id=&quot;fnref:zfc-casi&quot;&gt;&lt;a href=&quot;#fn:zfc-casi&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Un conjunto se dice
&lt;a href=&quot;https://en.wikipedia.org/wiki/Hereditary_set&quot;&gt;&lt;strong&gt;hereditario&lt;/strong&gt;&lt;/a&gt; si todos
sus elementos son conjuntos hereditarios. Como &lt;a href=&quot;https://en.wikipedia.org/wiki/Vacuous_truth&quot;&gt;verdad
vacua&lt;/a&gt; podemos demostrar
que el &lt;strong&gt;conjunto vacío&lt;/strong&gt; &lt;script type=&quot;math/tex&quot;&gt;\varnothing&lt;/script&gt; es un conjunto hereditario y por
tanto (como veremos a continuación) también lo serán
&lt;script type=&quot;math/tex&quot;&gt;\{\varnothing\}, \{\varnothing, \{\varnothing\}\},\{\{\varnothing\}\}, \dots&lt;/script&gt;.
Combinando conjuntos hereditarios a partir de los axiomas podemos crear
una cantidad arbitrariamente grande de conjuntos y por tanto nos basta
nombrar de forma especial algunos de estos conjuntos para obtener
nuestra teoría.&lt;/p&gt;

&lt;p&gt;La forma habitual de proceder es definir primero los números naturales
siguiendo los &lt;a href=&quot;https://en.wikipedia.org/wiki/Ordinal_number#Von_Neumann_definition_of_ordinals&quot;&gt;ordinales de Von
Neumann&lt;/a&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;0 = \varnothing, 1 = \{0\} = \{\varnothing\}, 2 = \{0,1\} = \{\varnothing,\{\varnothing\}\}, \dots&lt;/script&gt;

&lt;p&gt;De esta forma obtenemos los números naturales&lt;sup id=&quot;fnref:zfc-nats&quot;&gt;&lt;a href=&quot;#fn:zfc-nats&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;. A continuación para
obtener los enteros, racionales, reales y complejos podemos definirlos
mediante relaciones de equivalencia adecuadas. Puedes encontrar una
posible construcción explícita en &lt;a href=&quot;http://math.stackexchange.com/a/62868/135164&quot;&gt;esta pregunta de Stack
Exchange&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;las-funciones-son-conjuntos&quot;&gt;Las funciones son conjuntos&lt;/h3&gt;

&lt;p&gt;Una función es una operación que relaciona un elemento o tupla de
elementos de su dominio con un único elemento de su codominio. Para
formalizar este concepto podemos identificar (casi) todas las funciones
como un conjunto: su grafo.&lt;/p&gt;

&lt;p&gt;De esta forma una aplicación &lt;script type=&quot;math/tex&quot;&gt;f: A \to B&lt;/script&gt; puede verse como una 3-upla
&lt;script type=&quot;math/tex&quot;&gt;(A,B,G)&lt;/script&gt; con &lt;script type=&quot;math/tex&quot;&gt;G = \{(a,b) \in A \times B \;:\; b = f(a) \}&lt;/script&gt; &lt;sup id=&quot;fnref:zfc-funcion&quot;&gt;&lt;a href=&quot;#fn:zfc-funcion&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;No todas las funciones pueden expresarse como conjuntos: las operaciones
clásicas sobre conjuntos (unión, intersección, conjunto potencia) así
como la aplicación que devuelve la cardinalidad de un conjunto son
aplicaciones que tienen como dominio todos los conjuntos, pero en ZFC no
existe el conjunto de todos los conjuntos. Podemos ver a estas
“funciones” simplemente como notación.&lt;/p&gt;

&lt;h3 id=&quot;algunas-cosas-que-no-son-conjuntos&quot;&gt;Algunas cosas que no son conjuntos&lt;/h3&gt;

&lt;p&gt;En algunas partes de las matemáticas como la &lt;a href=&quot;https://libreim.github.io/blog/2014/10/04/intro-categorias/&quot;&gt;teoría de
categorías&lt;/a&gt;
resulta útil con frecuencia hablar de todos los conjuntos a la vez (por
ejemplo cuando queremos hablar de los objetos de la categoría
&lt;script type=&quot;math/tex&quot;&gt;\texttt{Set}&lt;/script&gt;) pero se nos presenta el problema de que (en ZFC) no
existe el &lt;a href=&quot;https://en.wikipedia.org/wiki/Universal_set&quot;&gt;&lt;em&gt;conjunto
universal&lt;/em&gt;&lt;/a&gt; (el conjunto de
todos los conjuntos). Para resolver este problema existen 3 opciones.&lt;/p&gt;

&lt;p&gt;En primer lugar podríamos utilizar una &lt;strong&gt;teoría axiomática distinta&lt;/strong&gt; que
incluyera la clase de todos los conjuntos como NBG. Esta teoría nos
permite utilizar todo lo que conocemos de ZFC añadiendo además nuevos
objetos que nos permiten hablar de colecciones más grandes sin inducir
paradojas.&lt;/p&gt;

&lt;p&gt;Otra opción es utilizar una teoría como la &lt;a href=&quot;http://math.stackexchange.com/a/234208/135164&quot;&gt;&lt;strong&gt;teoría de
Tarski-Grothendieck&lt;/strong&gt;&lt;/a&gt; que
incluye conjuntos que, si bien no son &lt;em&gt;el conjunto de todos los
conjuntos&lt;/em&gt; sí que comparten muchas de sus propiedades.&lt;/p&gt;

&lt;p&gt;Por último si queremos mantenernos en ZFC podemos introducir una &lt;strong&gt;nueva
notación&lt;/strong&gt; para hablar de clases: si &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; es una clase definida por una
propiedad &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt; introducimos el símbolo &lt;script type=&quot;math/tex&quot;&gt;\in C&lt;/script&gt; como un predicado que
indica &lt;em&gt;… tiene la propiedad P&lt;/em&gt;. De esta forma podemos utilizar una
notación parecida a la de los conjuntos para hablar de una cantidad
reducida de clases (aquellas definibles mediante una propiedad).&lt;/p&gt;

&lt;h2 id=&quot;los-axiomas&quot;&gt;Los axiomas&lt;/h2&gt;

&lt;p&gt;La teoría axiomática de conjuntos de ZFC es una extensión de la teoría
de conjuntos de Zermelo, descrita a principios del siglo XX como
respuesta a las paradojas de la teoría de conjuntos informal. Aunque
existen &lt;a href=&quot;https://en.wikipedia.org/wiki/Paraconsistent_logic&quot;&gt;corrientes filosóficas y
lógicas&lt;/a&gt; que
permiten la existencia de contradicciones, las reglas de inferencia de
la lógica clásica hacen que si un sistema axiomático no es consistente
(tiene contradicciones) entonces podamos &lt;a href=&quot;https://en.wikipedia.org/wiki/Principle_of_explosion&quot;&gt;demostrar cualquier
cosa&lt;/a&gt;. Por tanto
necesitamos establecer una teoría que no tenga esas contradicciones.&lt;/p&gt;

&lt;p&gt;La más famosa de las paradojas de la teoría de conjuntos informal es la
&lt;a href=&quot;https://en.wikipedia.org/wiki/Russell's_paradox&quot;&gt;paradoja de
Russell&lt;/a&gt;: &lt;em&gt;Si un
barbero afeita a todos los que no se afeitan a sí mismos, ¿se afeita a
sí mismo?&lt;/em&gt;. En términos de la teoría de conjuntos informal se traduce
en:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Sea &lt;script type=&quot;math/tex&quot;&gt;R = \{x \;:\; x \notin x\}&lt;/script&gt;. Entonces &lt;script type=&quot;math/tex&quot;&gt;R \in R&lt;/script&gt; si y sólo si
&lt;script type=&quot;math/tex&quot;&gt;R \notin R&lt;/script&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Otras paradojas que impulsaron la creación de esta teoría son la
&lt;a href=&quot;https://en.wikipedia.org/wiki/Cantor's_paradox&quot;&gt;paradoja de Cantor&lt;/a&gt;
(no existe el conjunto de todos los cardinales) y la &lt;a href=&quot;https://en.wikipedia.org/wiki/Burali-Forti_paradox&quot;&gt;paradoja de
Burali-Fort&lt;/a&gt; (no
existe el conjunto de todos los ordinales).&lt;/p&gt;

&lt;p&gt;Para resolver estas paradojas necesitamos especificar las reglas de
formación de los conjuntos de tal manera que sean suficientemente
fuertes para describir todas las matemáticas pero no lleven a
contradicción. En el caso de ZFC estas reglas son iterativas:
construiremos conjuntos más complejos a partir del conjunto vacío
formando el &lt;a href=&quot;https://en.wikipedia.org/wiki/Von_Neumann_universe&quot;&gt;universo de von
Neumann&lt;/a&gt;. A
continuación presentamos estas reglas (los axiomas) siguiendo la
descripción de &lt;em&gt;Kunen (1980)&lt;/em&gt;.&lt;/p&gt;

&lt;h3 id=&quot;existencia&quot;&gt;Existencia&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists x (x = x)&lt;/script&gt;

&lt;p&gt;En la mayor parte de las definiciones de la lógica de primer orden se
asume que &lt;a href=&quot;https://en.wikipedia.org/wiki/Empty_domain&quot;&gt;el dominio de discurso no es
vacío&lt;/a&gt;: si lo fuera muchas
de las reglas de inferencia y teoremas lógicos que se utilizan
normalmente no serían válidos en general. Por completitud añadimos este
axioma que nos indica que &lt;strong&gt;existe un conjunto&lt;/strong&gt; &lt;sup id=&quot;fnref:zfc-vacio&quot;&gt;&lt;a href=&quot;#fn:zfc-vacio&quot; class=&quot;footnote&quot;&gt;7&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h3 id=&quot;extensionalidad&quot;&gt;Extensionalidad&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \forall y (\forall z (z \in x \iff z \in y) \implies x = y)&lt;/script&gt;

&lt;p&gt;El axioma de extensionalidad nos indica que &lt;strong&gt;dos conjuntos son iguales
si tienen los mismos elementos&lt;/strong&gt;. Es decir, al definir un conjunto sólo
importan sus elementos, pero no el orden o el número de repeticiones de
cada elemento: &lt;script type=&quot;math/tex&quot;&gt;\{2,2,3,1\} = \{1,2,3\}&lt;/script&gt;&lt;/p&gt;

&lt;details class=&quot;ejercicio&quot;&gt;
  &lt;summary&gt;
    &lt;p&gt;&lt;em&gt;Definir &lt;script type=&quot;math/tex&quot;&gt;\subseteq&lt;/script&gt; y probar que es una relación de orden&lt;/em&gt;&lt;/p&gt;
  &lt;/summary&gt;

  &lt;p&gt;Definimos&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;a \subseteq b \iff \forall x (x \in a \implies x \in b)&lt;/script&gt;

  &lt;ul&gt;
    &lt;li&gt;Es &lt;strong&gt;reflexiva&lt;/strong&gt; porque &lt;script type=&quot;math/tex&quot;&gt;\implies&lt;/script&gt; es reflexiva&lt;/li&gt;
    &lt;li&gt;Es &lt;strong&gt;transitiva&lt;/strong&gt; porque &lt;script type=&quot;math/tex&quot;&gt;\implies&lt;/script&gt; es transitiva&lt;/li&gt;
    &lt;li&gt;Es &lt;strong&gt;antisimétrica&lt;/strong&gt;  por el axioma de extensionalidad&lt;/li&gt;
  &lt;/ul&gt;

&lt;/details&gt;

&lt;h3 id=&quot;comprensión&quot;&gt;Comprensión&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Si &lt;script type=&quot;math/tex&quot;&gt;\varphi(x)&lt;/script&gt; es una fórmula en la que &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; no es una variable libre
se verifica&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall z \exists y \forall x (x \in y \iff x \in z \wedge \varphi(x))&lt;/script&gt;

&lt;p&gt;Como vimos en la primera sección la lógica empleada para describir ZFC
es la lógica de primer orden, que sólo permite utilizar cuantificadores
sobre nuestro dominio de discurso: &lt;em&gt;los conjuntos&lt;/em&gt;. Por esta razón
cuando queremos hablar de algo que se cumple para todas las fórmulas
necesitamos incluir &lt;em&gt;esquemas de axioma&lt;/em&gt;: un conjunto de axiomas
parametrizados por las fórmulas&lt;sup id=&quot;fnref:zfc-segundo&quot;&gt;&lt;a href=&quot;#fn:zfc-segundo&quot; class=&quot;footnote&quot;&gt;8&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Obtenemos así una cantidad infinita (pero computable) de axiomas&lt;sup id=&quot;fnref:zfc-enumerable&quot;&gt;&lt;a href=&quot;#fn:zfc-enumerable&quot; class=&quot;footnote&quot;&gt;9&lt;/a&gt;&lt;/sup&gt;.
Estos axiomas nos indican que para cada &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; y cada propiedad &lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt;
los elementos de &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; que cumplen &lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt; forman un conjunto. Esto
justifica la notación &lt;script type=&quot;math/tex&quot;&gt;\{x \in z \;:\; \varphi(x)\}&lt;/script&gt;. Tienen sentido
entonces definiciones como
&lt;script type=&quot;math/tex&quot;&gt;\mathbb{R}^+ = \{x \in \mathbb{R} \;:\; x &gt; 0\}&lt;/script&gt;, pero no
&lt;script type=&quot;math/tex&quot;&gt;\{x : x = x\}&lt;/script&gt; (no hay &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt;) o conjuntos autorreferentes como
&lt;script type=&quot;math/tex&quot;&gt;Y = \{x : x \notin Y\}&lt;/script&gt; (&lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; es una variable libre en &lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt;).&lt;/p&gt;

&lt;details class=&quot;ejercicio&quot;&gt;
  &lt;summary&gt;
    &lt;p&gt;&lt;em&gt;Probar que existe el conjunto vacío:&lt;/em&gt;
&lt;script type=&quot;math/tex&quot;&gt;\exists \varnothing \forall x (x \notin \varnothing)&lt;/script&gt;&lt;/p&gt;
  &lt;/summary&gt;

  &lt;p&gt;Por el axioma de existencia existe un conjunto &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.&lt;/p&gt;

  &lt;p&gt;Definimos entonces &lt;script type=&quot;math/tex&quot;&gt;\varnothing = \{x \in A \;:\; x \neq x\}&lt;/script&gt;. Por el
axioma de reflexividad de la igualdad, ningún elemento pertenece a
&lt;script type=&quot;math/tex&quot;&gt;\varnothing&lt;/script&gt;.&lt;/p&gt;
&lt;/details&gt;

&lt;details class=&quot;ejercicio&quot;&gt;
  &lt;summary&gt;
    &lt;p&gt;&lt;em&gt;Probar que no existe el conjunto
universal:&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\nexists U \forall x (x \in U)&lt;/script&gt;&lt;/p&gt;
  &lt;/summary&gt;

  &lt;p&gt;Supongamos que existe &lt;script type=&quot;math/tex&quot;&gt;U&lt;/script&gt;.&lt;/p&gt;

  &lt;p&gt;Definimos entonces &lt;script type=&quot;math/tex&quot;&gt;R = \{x \in U \;:\; x \notin x\}&lt;/script&gt;. En tal caso
podemos aplicar la paradoja de Russell (&lt;script type=&quot;math/tex&quot;&gt;R \in R \iff R \notin R&lt;/script&gt;) y
tenemos una contradicción.&lt;/p&gt;
&lt;/details&gt;

&lt;p&gt;Diferentes teorías axiomáticas de conjuntos han tenido históricamente
esquemas de axioma de comprensión con distintas restricciones: el
primero de ellos, propuesto por Frege, es el &lt;a href=&quot;https://en.wikipedia.org/wiki/Axiom_schema_of_specification#Unrestricted_comprehension&quot;&gt;&lt;em&gt;esquema de axioma de
comprensión no
restringido&lt;/em&gt;&lt;/a&gt;:
Para cualquier fórmula &lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists z (\forall x (x \in z \iff \varphi(x)))&lt;/script&gt;

&lt;p&gt;Este axioma lleva a la paradoja de Russell y por esta razón se restringe
el esquema de axioma para definir sólo subconjuntos. Otra opción es
restringir la forma de la fórmula &lt;script type=&quot;math/tex&quot;&gt;\varphi&lt;/script&gt; de manera que esté
&lt;a href=&quot;https://en.wikipedia.org/wiki/Stratification_(mathematics)#In_set_theory&quot;&gt;estratificada&lt;/a&gt;.
Esta es la opción que adopta NF y que permite la construcción del
conjunto universal (pero NF tiene otras propiedades poco deseables: es
incompatible con el axioma de elección). Puedes leer más sobre otras
posibles formas del esquema de axioma de comprensión (como la de la
teoría de conjuntos constructiva, que sólo utiliza cuantificadores
delimitados) &lt;a href=&quot;https://ncatlab.org/nlab/show/axiom%2Bof%2Bseparation&quot;&gt;en
nLab&lt;/a&gt;.&lt;/p&gt;

&lt;details class=&quot;ejercicio&quot;&gt;
  &lt;summary&gt;
    &lt;p&gt;&lt;em&gt;Prueba que este esquema genera un número de axiomas numerable.&lt;/em&gt;&lt;/p&gt;
  &lt;/summary&gt;

  &lt;p&gt;El conjunto de axiomas que genera el esquema de axioma de comprensión es
equipotente al conjunto de fórmulas.&lt;/p&gt;

  &lt;p&gt;Sea &lt;script type=&quot;math/tex&quot;&gt;A = \{\forall,\exists,\in,=,(,),\implies,\neg,x_1,x_2,\dots\}&lt;/script&gt;. Es
claro que &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; es numerable. El conjunto de fórmulas es un subconjunto
de:&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;\bigcup_{n \in \mathbb{N}} A^n&lt;/script&gt;

  &lt;p&gt;Este conjunto es una unión numerable de conjuntos numerables (el
producto finito de numerables es numerable), por lo que es numerable.&lt;/p&gt;
&lt;/details&gt;

&lt;details class=&quot;ejercicio&quot;&gt;
  &lt;summary&gt;
    &lt;p&gt;&lt;em&gt;Define la intersección y la diferencia. ¿Puedes definir la unión?&lt;/em&gt;&lt;/p&gt;
  &lt;/summary&gt;

  &lt;ul&gt;
    &lt;li&gt;Si &lt;script type=&quot;math/tex&quot;&gt;\mathcal{F}&lt;/script&gt; es un conjunto de conjuntos a los que queremos
  hacer la intersección y &lt;script type=&quot;math/tex&quot;&gt;A \in \mathcal{F}&lt;/script&gt;:&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\bigcap \mathcal{F} = \{x \in A \;:\; \forall y (y \in \mathcal{F} \implies x \in y)\}&lt;/script&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;script type=&quot;math/tex; mode=display&quot;&gt;A-B = \{x \in A \;:\; x \notin B\}&lt;/script&gt;
    &lt;/li&gt;
    &lt;li&gt;Aunque el predicado &lt;script type=&quot;math/tex&quot;&gt;\exists y (y \in \mathcal{F} \wedge x \in y)&lt;/script&gt; es válido no podemos    definir la unión porque no conocemos un conjunto más grande que los conjuntos que queremos unir.&lt;/li&gt;
  &lt;/ul&gt;
&lt;/details&gt;

&lt;h3 id=&quot;par&quot;&gt;Par&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall a \forall b \exists z (a \in z \wedge b \in z)&lt;/script&gt;

&lt;p&gt;Este axioma justifica la expresión de conjuntos por enumeración: si &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;
y &lt;script type=&quot;math/tex&quot;&gt;b&lt;/script&gt; son dos conjuntos también lo será &lt;script type=&quot;math/tex&quot;&gt;\{a,b\}&lt;/script&gt; (y el axioma de
extensionalidad nos asegura además que esta expresión se refiere a un
único conjunto). Además, tomando &lt;script type=&quot;math/tex&quot;&gt;a = b&lt;/script&gt; tenemos que si &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; es un
conjunto también lo será &lt;script type=&quot;math/tex&quot;&gt;\{a,a\} = \{a\}&lt;/script&gt; (donde la igualdad se da por
el axioma de extensionalidad). Podemos además construir pares definiendo
&lt;script type=&quot;math/tex&quot;&gt;(a,b) = \{\{a\},\{a,b\}\}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;El conjunto vacío es el único conjunto cuya existencia podíamos probar
hasta el momento: los axiomas de existencia, extensionalidad y
comprensión son consistentes con &lt;script type=&quot;math/tex&quot;&gt;\forall y (y = \varnothing)&lt;/script&gt;. Con el
axioma del par podemos formar una cantidad infinita de conjuntos:
&lt;script type=&quot;math/tex&quot;&gt;\varnothing,\{\varnothing\}, \{\{\varnothing\}\},\dots&lt;/script&gt; aunque no
podemos justificar aún la existencia de ningún conjunto infinito (no
sabemos por ejemplo si
&lt;script type=&quot;math/tex&quot;&gt;\{\varnothing,\{\varnothing\}, \{\{\varnothing\}\},\dots\}&lt;/script&gt; es un
conjunto).&lt;/p&gt;

&lt;details class=&quot;ejercicio&quot;&gt;
  &lt;summary&gt;
    &lt;p&gt;&lt;em&gt;Probar que&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;(a,b) = (c,d) \iff a = c \wedge b = d&lt;/script&gt;&lt;/p&gt;
  &lt;/summary&gt;
  &lt;p&gt;Puedes leer la solución en &lt;a href=&quot;https://en.wikipedia.org/wiki/Ordered_pair#Proving_that_definitions_satisfy_the_characteristic_property&quot;&gt;Wikipedia&lt;/a&gt;.&lt;/p&gt;

  &lt;p&gt;Con el axioma de unión podemos generalizar esta definición para definir
&lt;script type=&quot;math/tex&quot;&gt;(a_1,\dots,a_n)&lt;/script&gt; para cualquier &lt;script type=&quot;math/tex&quot;&gt;n \in \mathbb{N}&lt;/script&gt;.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Extra&lt;/strong&gt;: ¿Cómo puedes generalizarla para tuplas con una cantidad
infinita arbitraria de posiciones?&lt;/p&gt;
&lt;/details&gt;

&lt;h3 id=&quot;unión&quot;&gt;Unión&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall \mathcal{F} \exists A \forall Y \forall x (x \in Y \wedge Y \in \mathcal{F} \implies x \in A)&lt;/script&gt;

&lt;p&gt;Como vimos en la sección del esquema de axioma de comprensión no podemos
definir la unión a partir de un predicado ya que necesitaríamos de la
existencia del conjunto universal.&lt;/p&gt;

&lt;p&gt;Para solucionarlo introducimos entonces el &lt;strong&gt;axioma de unión&lt;/strong&gt;: dada
cualquier colección de conjuntos &lt;script type=&quot;math/tex&quot;&gt;\mathcal{F} = \{A_{\lambda}\}\_{\Lambda}&lt;/script&gt; existe un conjunto &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;, que tiene todos los elementos de los &lt;script type=&quot;math/tex&quot;&gt;A\_\lambda&lt;/script&gt; (es decir, si
&lt;script type=&quot;math/tex&quot;&gt;x \in A\_\lambda&lt;/script&gt;, entonces &lt;script type=&quot;math/tex&quot;&gt;x \in A&lt;/script&gt;). Definimos a partir de este
conjunto la unión de una cantidad arbitaria de estos:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bigcup_{\lambda \in \Lambda} A_\lambda = \{ x \in A \;:\; \exists Y (x \in Y \wedge Y \in \mathcal{F})\}&lt;/script&gt;

&lt;p&gt;Obteniendo así justificación para las expresiones de la forma &lt;script type=&quot;math/tex&quot;&gt;A \cup B&lt;/script&gt;
(basta tomar &lt;script type=&quot;math/tex&quot;&gt;\mathcal{F} = \{A,B\}&lt;/script&gt;)y uniones de una cantidad
arbitraria de conjuntos en general.&lt;/p&gt;

&lt;p&gt;Utilizando el axioma de par y el axioma de unión podemos formar
conjuntos de cardinalidad finita arbitraria, pero no de cardinalidad
infinita.&lt;/p&gt;

&lt;h3 id=&quot;infinito&quot;&gt;Infinito&lt;/h3&gt;

&lt;p&gt;Para este axioma introducimos notación adicional para facilitar su
expresión: definimos &lt;script type=&quot;math/tex&quot;&gt;S(x) = x \cup \{x\}&lt;/script&gt; (la función sucesor)&lt;sup id=&quot;fnref:zfc-sucesor&quot;&gt;&lt;a href=&quot;#fn:zfc-sucesor&quot; class=&quot;footnote&quot;&gt;10&lt;/a&gt;&lt;/sup&gt;.
Con esta notación el axioma queda:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists X (\varnothing \in X \wedge \forall y (y \in X \implies S(y) \in X))&lt;/script&gt;

&lt;p&gt;Con lo que tenemos nuestro primer conjunto infinito. Podemos demostrar
que &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt; &lt;a href=&quot;https://en.wikipedia.org/wiki/Axiom_of_infinity#Extracting_the_natural_numbers_from_the_infinite_set&quot;&gt;tiene un
subconjunto&lt;/a&gt;
&lt;script type=&quot;math/tex&quot;&gt;\mathbb{N} \subseteq X&lt;/script&gt; que verifica los axiomas de Peano, tomando
&lt;script type=&quot;math/tex&quot;&gt;0 = \varnothing&lt;/script&gt; y &lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; la función sucesor.&lt;/p&gt;

&lt;p&gt;En sus orígenes este axioma fue
&lt;a href=&quot;https://en.wikipedia.org/wiki/Controversy_over_Cantor's_theory&quot;&gt;controvertido&lt;/a&gt;
ya que no era considerado una verdad evidente. Aceptar los axiomas de
&lt;a href=&quot;http://cantorsattic.info/Cantor's_Attic&quot;&gt;grandes cardinales&lt;/a&gt; para
nosotros es como aceptar el axioma de infinito para los
&lt;a href=&quot;https://ncatlab.org/nlab/show/finite%2Bmathematics%20&quot;&gt;finitistas&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;potencia&quot;&gt;Potencia&lt;/h3&gt;

&lt;p&gt;Como hemos hecho en anteriores axiomas definimos nueva notación para
simplificar la expresión de los axiomas. En este caso definimos
&lt;script type=&quot;math/tex&quot;&gt;x \subseteq y := \forall z (z \in x \implies z \in y)&lt;/script&gt;. El axioma
queda:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x \exists y \forall z (z \subseteq x \implies z \in y)&lt;/script&gt;

&lt;p&gt;Este axioma afirma la existencia, para cada conjunto &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; de un conjunto
&lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt; que habitualmente llamamos &lt;em&gt;conjunto potencia&lt;/em&gt; notado
&lt;script type=&quot;math/tex&quot;&gt;\mathcal{P}(x)&lt;/script&gt; que es el &lt;strong&gt;conjunto de todos los subconjuntos&lt;/strong&gt; de
&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;. Este axioma nos permite crear conjuntos de cardinalidad
arbitrariamente grande (ya que por el teorema de Cantor,
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
|A| &lt; |\mathcal{P}(A)| %]]&gt;&lt;/script&gt;) &lt;sup id=&quot;fnref:zfc-pst&quot;&gt;&lt;a href=&quot;#fn:zfc-pst&quot; class=&quot;footnote&quot;&gt;11&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;details class=&quot;ejercicio&quot;&gt;
  &lt;summary&gt;
    &lt;p&gt;&lt;em&gt;Define &lt;script type=&quot;math/tex&quot;&gt;A \times B&lt;/script&gt;&lt;/em&gt;&lt;/p&gt;
  &lt;/summary&gt;

  &lt;p&gt;Queremos un conjunto que tenga todas las parejas &lt;script type=&quot;math/tex&quot;&gt;(a,b) = \{\{a\},\{a,b\}\}&lt;/script&gt;
con &lt;script type=&quot;math/tex&quot;&gt;a \in A&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;b \in B&lt;/script&gt;.&lt;/p&gt;

  &lt;p&gt;Es claro que
&lt;script type=&quot;math/tex&quot;&gt;\{a\}, \{a,b\} \in \mathcal{P}(A \cup B)&lt;/script&gt;. Por tanto:&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;A \times B = \{x \in \mathcal{P}(\mathcal{P}(A \cup B)) \;:\; x = (a,b), a \in A, b \in B\}&lt;/script&gt;

  &lt;p&gt;También podemos hacerlo con el esquema de axioma de reemplazamiento y el
axioma del par.&lt;/p&gt;

  &lt;p&gt;&lt;strong&gt;Extra:&lt;/strong&gt; ¿Cómo podemos definir un producto cartesiano de una cantidad
arbitaria de conjuntos?&lt;/p&gt;
&lt;/details&gt;

&lt;h3 id=&quot;reemplazamiento&quot;&gt;Reemplazamiento&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Si&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\varphi(x,y)&lt;/script&gt; &lt;em&gt;es una fórmula en la que&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;w&lt;/script&gt; &lt;em&gt;no es una variable
libre,&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;z&lt;/script&gt; &lt;em&gt;es un conjunto y se tiene&lt;/em&gt;
&lt;script type=&quot;math/tex&quot;&gt;\forall x \; x \in z \implies \exists ! y \; \varphi(x,y)&lt;/script&gt; &lt;em&gt;se
verifica&lt;/em&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists w \; \forall x (x \in z \implies \exists y (y \in w \wedge \varphi(x,y)))&lt;/script&gt;

&lt;p&gt;La teoría original de Zermelo no incluía este esquema de axioma, que fue
incluido por Fraenkel para justificar la existencia de conjuntos como
&lt;script type=&quot;math/tex&quot;&gt;\{\mathbb{N}, \mathcal{P}(\mathbb{N}), \mathcal{P}(\mathcal{P}(\mathbb{N})),\dots\}&lt;/script&gt;,
útiles en la teoría de los ordinales&lt;sup id=&quot;fnref:zfc-borel&quot;&gt;&lt;a href=&quot;#fn:zfc-borel&quot; class=&quot;footnote&quot;&gt;12&lt;/a&gt;&lt;/sup&gt;. Este esquema de axioma
implica el esquema de axioma de comprensión y el axioma del par. Es poco
utilizado: la mayor parte de las matemáticas pueden construirse sin
utilizar este axioma. La idea del axioma es que la única cualidad que
define si una colección es o no un conjunto es su tamaño.&lt;/p&gt;

&lt;p&gt;Este axioma necesita el concepto de &lt;strong&gt;predicado funcional&lt;/strong&gt;: una fórmula
&lt;script type=&quot;math/tex&quot;&gt;\varphi(x,y)&lt;/script&gt; que asocia a cada &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; un único &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;. De esta forma el
axioma nos permite &lt;em&gt;reemplazar&lt;/em&gt; los &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; por su correspondiente &lt;script type=&quot;math/tex&quot;&gt;y&lt;/script&gt;. Esto
justifica la notación ocasionalmente utilizada
&lt;script type=&quot;math/tex&quot;&gt;\{F(x) \; : \; x \in A\}&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Cabe destacar que las funciones &lt;strong&gt;no&lt;/strong&gt; son predicados funcionales: los
predicados son numerables mientras que las funciones no lo son. De la
misma forma los predicados funcionales &lt;strong&gt;no&lt;/strong&gt; son funciones:
&lt;script type=&quot;math/tex&quot;&gt;\varphi(x,y) := y = \mathcal{P}(x)&lt;/script&gt; no puede expresarse como función en
ZFC.&lt;/p&gt;

&lt;details class=&quot;ejercicio&quot;&gt;
  &lt;summary&gt;
    &lt;p&gt;&lt;em&gt;Prueba que reemplazamiento implica comprensión&lt;/em&gt;&lt;/p&gt;
  &lt;/summary&gt;

  &lt;p&gt;Puedes encontrar la respuesta en &lt;a href=&quot;https://math.stackexchange.com/questions/32483&quot;&gt;Math
  StackExchange&lt;/a&gt;.&lt;/p&gt;

&lt;/details&gt;

&lt;details class=&quot;ejercicio&quot;&gt;
  &lt;summary&gt;
    &lt;p&gt;&lt;em&gt;¿Existe el conjunto de todos los espacios topológicos?&lt;/em&gt;&lt;/p&gt;
  &lt;/summary&gt;

  &lt;p&gt;Supongamos que exista el
conjunto de todos los espacios topológicos. Definimos el predicado
funcional &lt;script type=&quot;math/tex&quot;&gt;F((X,\tau_T)) = X&lt;/script&gt;.&lt;/p&gt;

  &lt;p&gt;Como todo conjunto es un espacio topológico con la topología trivial
tenemos que: &lt;script type=&quot;math/tex&quot;&gt;\{X \;:\; (X,\tau) \in T\} = U&lt;/script&gt;, el conjunto universal,
que como ya probamos no existe. Por tanto &lt;strong&gt;no&lt;/strong&gt;, no existe el conjunto
de todos los espacios topológicos.&lt;/p&gt;

  &lt;p&gt;Demostraciones similares pueden utilizarse para probar que no existe el
conjunto de todos lo grupos o el conjunto de todas las categorías.&lt;/p&gt;
&lt;/details&gt;

&lt;h3 id=&quot;elección&quot;&gt;Elección&lt;/h3&gt;

&lt;p&gt;La introducción del axioma de infinito presenta un problema ya que no
todas las propiedades que podríamos deducir del resto de axiomas sobre
cualquier conjunto finito pueden generalizarse a los conjuntos
infinitos. Es el caso del &lt;strong&gt;axioma de elección&lt;/strong&gt;. Para simplificar su
exposición asumimos bien definido el concepto de función.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall \mathcal{F} \left[ \emptyset \notin \mathcal{F} \implies \exists f : \mathcal{F} \to \bigcup \mathcal{F} \quad \forall A (A \in \mathcal{F} \implies f(A) \in A)\right]&lt;/script&gt;

&lt;p&gt;Es decir: Dada una familia de conjuntos no vacios &lt;script type=&quot;math/tex&quot;&gt;\mathcal{F}&lt;/script&gt; podemos
elegir un conjunto de cada uno de ellos. Equivalentemente, el producto
cartesiano de una familia de conjuntos no vacíos es no vacío.&lt;/p&gt;

&lt;p&gt;El axioma de elección es controvertido para los matemáticos
&lt;a href=&quot;https://en.wikipedia.org/wiki/Constructivism_(mathematics)&quot;&gt;constructivistas&lt;/a&gt;
porque permite demostrar la existencia de ciertos objetos sin dar una
construcción explícita de los mismos. Además permite demostrar
resultados chocantes como la &lt;a href=&quot;https://en.wikipedia.org/wiki/Banach%E2%80%93Tarski_paradox&quot;&gt;paradoja de
Banach-Tarski&lt;/a&gt;.
No obstante es un axioma esencial para la justificación de muchas
propiedades matemáticas básicas. &lt;a href=&quot;https://en.wikipedia.org/wiki/Axiom_of_choice#Equivalents&quot;&gt;Son
equivalentes&lt;/a&gt;
al axioma de elección:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Toda función sobreyectiva tiene inversa por la derecha&lt;/li&gt;
  &lt;li&gt;Todo espacio vectorial tiene una base&lt;/li&gt;
  &lt;li&gt;El producto de espacios topológicos compactos es compacto&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;También &lt;a href=&quot;https://en.wikipedia.org/wiki/Axiom_of_choice#Results_requiring_AC_.28or_weaker_forms.29_but_weaker_than_it&quot;&gt;es
necesario&lt;/a&gt;
para la demostración de algunos teoremas básicos (aunque no es
equivalente a estos):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;La unión de una cantidad numerable de conjuntos numerables es
numerable&lt;/li&gt;
  &lt;li&gt;Existe un conjunto que no es medible Lebesgue&lt;/li&gt;
  &lt;li&gt;Si &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; es infinito existe una aplicación inyectiva
&lt;script type=&quot;math/tex&quot;&gt;f:\mathbb{N} \to A&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fundación&quot;&gt;Fundación&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall x [x \neq \varnothing \implies \exists y (y \in x \wedge x \cap y = \varnothing)]&lt;/script&gt;

&lt;blockquote&gt;
  &lt;p&gt;The Axiom of Foundation is, as always in mathematics, totally
irrelevant - Kunen (1980)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;El axioma de fundación es un axioma poco utilizado que elimina conjuntos
de la forma &lt;script type=&quot;math/tex&quot;&gt;x = \{x\}&lt;/script&gt; o secuencias infinitas de la forma
&lt;script type=&quot;math/tex&quot;&gt;\dots \in x_3 \in x_2 \in x_1&lt;/script&gt;. La mayor parte de las matemáticas
pueden construirse sin utilizar este axioma, que nos sirve para excluir
estos casos patológicos. Es el segundo de los axiomas introducidos por
Fraenkel.&lt;/p&gt;

&lt;h2 id=&quot;lecturas-adicionales&quot;&gt;Lecturas adicionales&lt;/h2&gt;

&lt;p&gt;Algunos textos clásicos sobre el tema y páginas en las que puedes leer
más sobre el tema son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Set_Theory:_An_Introduction_to_Independence_Proofs&quot;&gt;Set Theory: An Introduction to Independence
Proofs&lt;/a&gt; -
Kenneth Kunen&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.math.wisc.edu/~miller/old/m771-10/kunen770.pdf&quot;&gt;Foundations of
Mathematics&lt;/a&gt; -
Kenneth Kunen&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Zermelo%E2%80%93Fraenkel_set_theory&quot;&gt;Zermelo-Fraenkel set
theory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory&quot;&gt;Von Neumann–Bernays–Gödel set
theory&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Naive_Set_Theory_(book)&quot;&gt;Naive Set
Theory&lt;/a&gt; -
Halmos&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:zfc-alternativas&quot;&gt;
      &lt;p&gt;Algunos ejemplos de teorías fundacionales alternativas son las
&lt;a href=&quot;https://ncatlab.org/nlab/show/structural+set+theory&quot;&gt;teorías de conjuntos
estructurales&lt;/a&gt;,
las &lt;a href=&quot;https://en.wikipedia.org/wiki/Homotopy_type_theory&quot;&gt;teorías de
tipos&lt;/a&gt; o la
&lt;a href=&quot;https://ncatlab.org/nlab/show/ETCC&quot;&gt;teoría de categorías&lt;/a&gt;. La
equivalencia entre estas tres teorías fundacionales se expone en
&lt;strong&gt;&lt;a href=&quot;https://www.andrew.cmu.edu/user/awodey/preprints/stcsFinal.pdf&quot;&gt;From Sets to Types to Categories to
Sets&lt;/a&gt;&lt;/strong&gt; &lt;a href=&quot;#fnref:zfc-alternativas&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-cuervos&quot;&gt;
      &lt;p&gt;Un &lt;a href=&quot;https://en.wikipedia.org/wiki/Raven_paradox&quot;&gt;ejemplo clásico de paradoja&lt;/a&gt; en la filosofía de la ciencia. &lt;a href=&quot;#fnref:zfc-cuervos&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-dominio&quot;&gt;
      &lt;p&gt;Uno puede preguntarse a qué se refieren las &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; en &lt;script type=&quot;math/tex&quot;&gt;\forall x&lt;/script&gt;.
Después de todo, como veremos en la sección de los axiomas ¡el
dominio de discurso estándar de la teoría de conjuntos no puede
verse como un conjunto! Existen diferentes formas de tratar con este
problema: podemos adoptar una &lt;a href=&quot;http://math.stackexchange.com/a/121131/135164&quot;&gt;postura
formalista&lt;/a&gt; y ver la
lógica como unas &lt;em&gt;reglas de manipulación de símbolos&lt;/em&gt; o utilizar
&lt;a href=&quot;https://plato.stanford.edu/entries/plural-quant/#SetThe&quot;&gt;cuantificación
plural&lt;/a&gt;
(ver también &lt;a href=&quot;http://math.stackexchange.com/a/1087050/135164&quot;&gt;esta pregunta de
SE&lt;/a&gt;). Nótese que (si
expresamos ZFC en lógica de primer orden) &lt;a href=&quot;https://en.wikipedia.org/wiki/L%C3%B6wenheim%E2%80%93Skolem_theorem&quot;&gt;sí existen modelos de
ZFC&lt;/a&gt;
    que pueden expresarse en ZFC, pero estos no son el modelo estándar. &lt;a href=&quot;#fnref:zfc-dominio&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-casi&quot;&gt;
      &lt;p&gt;Bueno, &lt;em&gt;casi&lt;/em&gt; exclusivamente, también necesitamos clases y
conglomerados como veremos a continuación. &lt;a href=&quot;#fnref:zfc-casi&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-nats&quot;&gt;
      &lt;p&gt;No son la única definición posible: podríamos utilizar
&lt;script type=&quot;math/tex&quot;&gt;\varnothing,\{\varnothing\},\{\{\varnothing\}\},\dots&lt;/script&gt; (esta es la definición que adoptó Zermelo). Sin embargo
con la definición dada en este post tenemos algunas propiedades
interesantes: por ejemplo &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
a &lt; b \iff a \in b %]]&gt;&lt;/script&gt; lo que nos permite un tratamiento
más sencillo de la teoría de los ordinales. La &lt;a href=&quot;https://ncatlab.org/nlab/show/structural+set+theory&quot;&gt;teoría estructural de conjuntos&lt;/a&gt; no distingue entre las distintas posibles construcciones de los números naturales u otros objetos sino que los define según sus propiedades. &lt;a href=&quot;#fnref:zfc-nats&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-funcion&quot;&gt;
      &lt;p&gt;Nótese que si cualquier gráfica es una función estamos considerando la &lt;a href=&quot;https://en.wikipedia.org/wiki/Empty_function&quot;&gt;función vacía&lt;/a&gt;, que algunos autores excluyen. &lt;a href=&quot;#fnref:zfc-funcion&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-vacio&quot;&gt;
      &lt;p&gt;Incluso no asumiendo un dominio de discurso no vacío el axioma de
infinito también nos indica que existe un conjunto pero para reducir
la complejidad de la exposición de ZFC es interesante añadir este
axioma. &lt;a href=&quot;#fnref:zfc-vacio&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-segundo&quot;&gt;
      &lt;p&gt;Si expresáramos ZFC en lógica de segundo orden los esquemas de
axioma incluidos podrían simplemente expresarse como axiomas
añadiendo un cuantificador sobre el predicado correspondiente.
La demostración de que ZF(C) no es finitamente axiomatizable puede
encontrarse en &lt;em&gt;Kunen (1980) página 138&lt;/em&gt;. Sin embargo &lt;a href=&quot;https://en.wikipedia.org/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory&quot;&gt;NBG&lt;/a&gt;
&lt;strong&gt;sí&lt;/strong&gt; es finitamente axiomatizable y es una extensión conservativa
de ZFC (es decir, todo teorema en ZFC es teorema en NBG). &lt;a href=&quot;#fnref:zfc-segundo&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-enumerable&quot;&gt;
      &lt;p&gt;Es decir, el lenguaje de los axiomas debe ser &lt;a href=&quot;https://en.wikipedia.org/wiki/Recursively_enumerable_language&quot;&gt;recursivamente
enumerable&lt;/a&gt;.
Esto nos permite verificar que una prueba es correcta en una
cantidad finita de tiempo y nos impide tener como axiomas todos los
teoremas. &lt;a href=&quot;#fnref:zfc-enumerable&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-sucesor&quot;&gt;
      &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;S&lt;/script&gt; no es una función si no la restringimos a algún dominio, sino
simplemente notación: su dominio y codominio deberían ser el
conjunto universal que no existe. &lt;a href=&quot;#fnref:zfc-sucesor&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-pst&quot;&gt;
      &lt;p&gt;Algunos autores defienden que no necesitamos conjuntos de
cardinalidad arbitrariamente grande ya que la mayor parte de las
matemáticas suceden en conjuntos numerables o equipotentes a los
números reales. La &lt;a href=&quot;https://en.wikipedia.org/wiki/Pocket_set_theory&quot;&gt;&lt;em&gt;teoría de conjuntos de
bolsillo&lt;/em&gt;&lt;/a&gt; propone
una alternativa en la que sólo existen conjuntos infinitos de estas
dos cardinalidades. &lt;a href=&quot;#fnref:zfc-pst&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:zfc-borel&quot;&gt;
      &lt;p&gt;Además es necesario para demostrar el &lt;a href=&quot;https://en.wikipedia.org/wiki/Borel_determinacy_theorem&quot;&gt;teorema de determinación
de Borel&lt;/a&gt;. &lt;a href=&quot;#fnref:zfc-borel&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
            <pubDate>Sat, 25 Mar 2017 00:00:00 +0000</pubDate>
            <link>/blog/2017/03/25/zfc/</link>
            <guid isPermaLink="true">/blog/2017/03/25/zfc/</guid>
        </item>
        
        <item>
            <title>Apuntes de Álgebra II</title>
            <description>&lt;p&gt;En los repositorios de LibreIM se han añadido unos &lt;a href=&quot;https://github.com/libreim/apuntesalgebraii/blob/master/apuntesalgebraii/algebra2.pdf&quot;&gt;apuntes que se corresponden con el temario de la asignatura Álgebra II&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Las aportaciones para mejorar estos apuntes son bienvenidas. En particular, en el archivo pdf del repositorio se incluyen los teoremas de Sylow, que se perdieron en la versión del código latex. También son bienvenidas contribuciones que completen las demostraciones de los teoremas enunciados o amplíen el material existente.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/libreim/apuntesalgebraii/tree/master/apuntesalgebraii&quot;&gt;Enlace al repositorio&lt;/a&gt;&lt;/p&gt;
</description>
            <pubDate>Tue, 07 Feb 2017 00:00:00 +0000</pubDate>
            <link>/blog/2017/02/07/apuntes-de-lgebra-ii-en/</link>
            <guid isPermaLink="true">/blog/2017/02/07/apuntes-de-lgebra-ii-en/</guid>
        </item>
        
        <item>
            <title>Mónadas</title>
            <description>&lt;blockquote&gt;
  &lt;p&gt;A monad is just a monoid in the category of endofunctors, what’s the problem?&lt;/p&gt;

  &lt;p&gt;– &lt;strong&gt;Philip Walder&lt;/strong&gt; (apócrifa) en &lt;em&gt;&lt;a href=&quot;http://james-iry.blogspot.com.es/2009/05/brief-incomplete-and-mostly-wrong.html&quot;&gt;A Brief, Incomplete, and Mostly Wrong History of programming languages&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;prerrequisitos&quot;&gt;Prerrequisitos&lt;/h2&gt;

&lt;p&gt;Este artículo requiere un conocimiento previo de Haskell, o al menos,
de otro lenguaje de programación funcional. Puedes consultar
nuestra &lt;a href=&quot;/blog/2014/10/01/intro-haskell/&quot;&gt;introducción a Haskell&lt;/a&gt;
con recursos para iniciarte en el lenguaje.&lt;/p&gt;

&lt;p&gt;Por otro lado, para la segunda parte del artículo es recomendable
conocimiento previo sobre teoría de categorías. Aun así, no es
necesaria para leer la primera parte del artículo, donde hablamos
de mónadas sin hacer ninguna referencia explícita a la teoría de
categorías. Si quieres leer sobre ese tema, puedes consultar nuestros apuntes
de &lt;a href=&quot;/blog/2014/10/04/intro-categorias/&quot;&gt;introducción a teoría de categorías&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;motivación-para-las-mónadas&quot;&gt;Motivación para las mónadas&lt;/h2&gt;

&lt;h3 id=&quot;mónadas-en-haskell&quot;&gt;Mónadas en Haskell&lt;/h3&gt;

&lt;p&gt;Imaginemos que necesitamos controlar cuando una función interna
devuelve un error, o cuando usa un estado que debe ser pasado al resto
de funciones. Cuando trabajamos con programación funcional pura,
debemos devolver explícitamente el error (señalar cómo va a tratarlo
cada función) o pasar el estado como argumento a cada una de las
funciones; así que una solución sería modificar cada una de las
funciones que usamos para que tenga en cuenta ese estado o ese caso de
error, pero esto añadiría mucha complejidad innecesaria a nuestro
código. La estructura de mónada simplifica esta escritura.&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;El siguiente ejemplo, en el que tratamos el manejo de errores encapsulado
en una mónada, está inspirado en los ejemplos de:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf&quot;&gt;Monads for functional programming&lt;/a&gt; - &lt;em&gt;Philip Wadler&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Que es una muy buena introducción al uso de las mónadas en programación
funcional.&lt;/p&gt;

&lt;h3 id=&quot;calculando-raíces-cuadradas&quot;&gt;Calculando raíces cuadradas&lt;/h3&gt;
&lt;p&gt;Por ejemplo, supongamos que intentamos sacar raíces cuadradas en los reales usando
el &lt;a href=&quot;https://en.wikipedia.org/wiki/Integer_square_root#Algorithm&quot;&gt;método de Newton&lt;/a&gt;.
Si intentamos calcular &lt;script type=&quot;math/tex&quot;&gt;\sqrt{n}&lt;/script&gt;, podemos tomar a cada paso la aproximación:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_{k+1} = \frac{1}{2}\left( x_k+\frac{n}{x_k} \right)&lt;/script&gt;

&lt;p&gt;Y parar cuando estemos suficientemente cerca (más cerca que un ε dado):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
|x_{k+1} - x_k| &lt; \varepsilon %]]&gt;&lt;/script&gt;

&lt;p&gt;Escribimos una implementación de ese concepto de convergencia para listas infinitas en Haskell
y del método de Newton, basado en la función &lt;a href=&quot;http://hackage.haskell.org/package/base-4.9.0.0/docs/Prelude.html#v:iterate&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;iterate&lt;/code&gt;&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epsilon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;abs&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epsilon&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherwise&lt;/span&gt;           &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;epsilon&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;newtonaprox&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;newtonaprox&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;sqroot&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sqroot&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sqroot&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.03&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newtonaprox&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ahora imaginemos que usamos esta raíz cuadrada recién definida para solucionar una ecuación
de segundo grado &lt;script type=&quot;math/tex&quot;&gt;x^2 + bx + c = 0&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x = \frac{-b \pm \sqrt{b^2 - 4c}}{2}&lt;/script&gt;

&lt;p&gt;Podemos definir una estructura de datos &lt;code class=&quot;highlighter-rouge&quot;&gt;QPol&lt;/code&gt; para el polinomio y una
función que lo resuelva obteniendo sus dos raíces:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;QPol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;QPol&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Show&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;QPol&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Qpol&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;x² + &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;x + &quot;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;show&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;solve&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;QPol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;solve&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;QPol&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sol1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sol2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sol1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqroot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;sol2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqroot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Y podemos comprobar que funciona:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;λ&amp;gt; pol = QPol 1 (-5) 6
λ&amp;gt; putStrLn $ &quot;Las soluciones de &quot; ++ show pol ++ &quot; son &quot; ++ solve pol
Las soluciones de 1.0x² + -5.0x + 6.0 son (3.0,2.0)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;controlando-los-errores&quot;&gt;Controlando los errores&lt;/h3&gt;

&lt;p&gt;Pero ¿qué ocurre cuando intentamos calcular la raíz cuadrada de un número no positivo?
Este método no la encuentra, por lo que debería devolver un error antes de intentar
empezar a calcularla. La solución obvia es reflejar este error con un &lt;code class=&quot;highlighter-rouge&quot;&gt;Maybe&lt;/code&gt; en el
cálculo de la raíz cuadrada.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.0&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;otherwise&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;0.03&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterate&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;newtonsqrt&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Esto lo soluciona, pero nos crea un problema mayor. La función &lt;code class=&quot;highlighter-rouge&quot;&gt;solve&lt;/code&gt; está usando la
raíz cuadrada y se espera de ella que devuelva un número, no un posible error. Si queremos
conseguir que funcione con la nueva &lt;code class=&quot;highlighter-rouge&quot;&gt;sqroot'&lt;/code&gt;, necesitaríamos implementar todas sus componentes
internas teniendo en cuenta ese error. Por ejemplo, deberíamos reescribir el &lt;code class=&quot;highlighter-rouge&quot;&gt;(+)&lt;/code&gt;, para tener
en cuenta errores y propagarlos por todos los cálculos involucrando a &lt;code class=&quot;highlighter-rouge&quot;&gt;sqroot'&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Pero esto es muy pesado de implementar; deberíamos implementarlo ¡para
cada una de las operaciones que usen la raíz cuadrada en algún punto!
Esto obliga a cada una de nuestras operaciones intermedias a ser
conscientes de la posibilidad de error, dándonos código mucho menos
modular y reusable.&lt;/p&gt;

&lt;p&gt;Una solución ligeramente mejor es la de abstraer este proceso de hacer
a una función consciente de la posibilidad de error en una función
aparte y definir las demás en función suya:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;errorAware&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;errorAware&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;errorAware&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;errorAware&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;op&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorAware&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*.&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errorAware&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Esto nos permite hacer cálculos con ellas:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;λ&amp;gt; sqroot' (-3) +. Just 4
Nothing
λ&amp;gt; sqroot' 3 +. Just 4
Just 5.732143
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;la-mónada-maybe&quot;&gt;La mónada Maybe&lt;/h3&gt;

&lt;p&gt;Esta idea para simplificar el tratamiento de errores, realizada
correctamente, es lo que nos va a proporcionar la estructura de
mónada. En Haskell, podemos definir una mónada como:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Monad&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;La idea intuitiva es que &lt;code class=&quot;highlighter-rouge&quot;&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; nos permite tomar una función que
puede devolver errores pero que no comprueba a la entrada si ha
recibido un error, es decir, de tipo &lt;code class=&quot;highlighter-rouge&quot;&gt;(a -&amp;gt; Maybe b)&lt;/code&gt; ; y aplicarla
sobre una función que puede contener un error. La podríamos usar por
ejemplo para componer varias &lt;code class=&quot;highlighter-rouge&quot;&gt;sqroot'&lt;/code&gt;, que era algo que hasta ahora
no podíamos hacer sin tratar cada posible caso de error.  Y la función
&lt;code class=&quot;highlighter-rouge&quot;&gt;return&lt;/code&gt;, que en este caso es simplemente &lt;code class=&quot;highlighter-rouge&quot;&gt;Just&lt;/code&gt;, nos permite
considerar una constante como un posible error. Podemos calcular
fácilmente así &lt;script type=&quot;math/tex&quot;&gt;\sqrt{\sqrt{3}}&lt;/script&gt; teniendo en cuenta los casos de error:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;-- ¡Error de tipos!&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;-- Usando mónadas&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt;   &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- Usando Just&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- Equivalente a lo anterior&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;notación-do&quot;&gt;Notación do&lt;/h3&gt;

&lt;p&gt;Las mónadas definen las funciones anteriores y muchas más que no vamos
a tratar ahora mismo, pero como resultado, nos acaban ofreciendo la
&lt;strong&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/do_notation&quot;&gt;notación do&lt;/a&gt;&lt;/strong&gt;,
que es la que podemos usar para acabar escribiendo nuestra función
&lt;code class=&quot;highlighter-rouge&quot;&gt;solve&lt;/code&gt; como:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;solve&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;QPol&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Maybe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Float&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;solve&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;QPol&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;discriminant&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqroot'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discriminant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discriminant&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;En la primera línea tenemos en cuenta que la función &lt;code class=&quot;highlighter-rouge&quot;&gt;sqroot&lt;/code&gt; puede
producir error, y en la segunda simplemente usamos el &lt;em&gt;posible&lt;/em&gt;
resultado de ella sin tener que preocuparnos por el resto de
funciones.&lt;/p&gt;

&lt;p&gt;Nótese que la notación &lt;strong&gt;do&lt;/strong&gt; es sólo una notación diseñada para
aliviar la escritura de operaciones con mónadas en algunos casos
particulares; es sólo &lt;em&gt;azúcar sintáctico&lt;/em&gt; para operaciones que no
dejan de ser puramente funcionales. Existen críticas al uso de esta
notación. &lt;sup id=&quot;fnref:do-notation-harmful&quot;&gt;&lt;a href=&quot;#fn:do-notation-harmful&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h2 id=&quot;mónadas-en-programación-funcional&quot;&gt;Mónadas en programación funcional&lt;/h2&gt;

&lt;h3 id=&quot;mónadas-como-clase-de-tipos&quot;&gt;Mónadas como clase de tipos&lt;/h3&gt;

&lt;p&gt;Las mónadas en Haskell están definidas como una clase de tipos
teniendo:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Un &lt;strong&gt;constructor&lt;/strong&gt; de tipos &lt;code class=&quot;highlighter-rouge&quot;&gt;m :: * -&amp;gt; *&lt;/code&gt;, que para cada tipo &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;,
devuelve una mónada conteniéndolo, &lt;code class=&quot;highlighter-rouge&quot;&gt;m a&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Una &lt;strong&gt;función&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;return :: a -&amp;gt; m a&lt;/code&gt;, que para todo elemento de tipo
&lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;, devuelve una mónada que lo contiene.&lt;/li&gt;
  &lt;li&gt;Una &lt;strong&gt;función&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;(&amp;gt;&amp;gt;=) :: m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b&lt;/code&gt;, que dada una
mónada y una función que se aplique sobre su interior y devuelva
otra mónada, devuelve la mónada resultante. Sirve como composición
de funciones monádicas.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La existencia de la última función equivale a la existencia de otras
dos funciones:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;fmap :: (a -&amp;gt; b) -&amp;gt; m a -&amp;gt; m b
join :: m (m a) -&amp;gt; m a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nótese entonces que para ser mónada, una clase de tipos debe ser primero
un funtor. Dentro de los funtores que conocemos, podemos reconocer algunas
mónadas, incluyendo la mónada &lt;code class=&quot;highlighter-rouge&quot;&gt;Maybe&lt;/code&gt; que hemos usado hasta ahora:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- Return de la mónada Maybe&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- Bind de la mónada Maybe&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Just&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Nothing&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- Return de la mónada List&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- Bind de la mónada List&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;xs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Puedes empezar a leer tutoriales sobre el uso de las mónadas en
Haskell en:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://learnyouahaskell.com/a-fistful-of-monads&quot;&gt;A fistful of monads - Learn you a Haskell&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikibooks.org/wiki/Haskell/Understanding_monads&quot;&gt;Understanding monads - Wikibooks&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mónada-lista&quot;&gt;Mónada lista&lt;/h3&gt;
&lt;p&gt;En las listas, por ejemplo, tenemos como candidato para &lt;code class=&quot;highlighter-rouge&quot;&gt;join :: [[a]] -&amp;gt; [a]&lt;/code&gt; 
la concatenación de listas, &lt;code class=&quot;highlighter-rouge&quot;&gt;concat&lt;/code&gt;. Nuestro &lt;code class=&quot;highlighter-rouge&quot;&gt;return :: a -&amp;gt; [a]&lt;/code&gt; será 
simplemente incluir un elemento en una lista que sólo lo contenga a él.&lt;/p&gt;

&lt;p&gt;En esta mónada, &lt;code class=&quot;highlighter-rouge&quot;&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt; mapea una función &lt;code class=&quot;highlighter-rouge&quot;&gt;a -&amp;gt; [a]&lt;/code&gt; sobre cada
elemento de la lista y concatena todos los resultados:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;λ&amp;gt; [1,2,3] &amp;gt;&amp;gt;= (replicate 3)
[1,1,1,2,2,2,3,3,3]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Nótese que, de la misma manera en la que podemos usar &lt;code class=&quot;highlighter-rouge&quot;&gt;(&amp;gt;&amp;gt;=)&lt;/code&gt;, podemos usar una versión con sus
parámetros cambiados de orden, &lt;code class=&quot;highlighter-rouge&quot;&gt;(=&amp;lt;&amp;lt;)&lt;/code&gt;. Aquí usamos la mónada lista para enumerar los racionales
repitiendo elementos:&lt;sup id=&quot;fnref:fpearls-rationals&quot;&gt;&lt;a href=&quot;#fn:fpearls-rationals&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.List&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Data.Ratio&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- Crea los racionales con denominador n&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;withDenom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Integral&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Rational&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;withDenom&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;map&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- Para cada entero, crea los racionales que lo&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;-- tienen como denominador&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rationalsDup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Rational&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rationalsDup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withDenom&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;..&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- Evita duplicados con 'nub'&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rationals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;Rational&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;rationals&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nub&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rationalsDup&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;mónada-io&quot;&gt;Mónada IO&lt;/h3&gt;
&lt;p&gt;La mónada IO surge como una solución al problema de implementar
efectos secundarios (como la lectura o escritura) en un lenguaje puro
y de forma extensible, sin tener que alterar el sistema de tipos y
respetando el orden en el que queremos que se ejecuten.&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;IO&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;greeting&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hola, &quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getLine&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Pueden leerse más detalles sobre mónada IO y su implementación en:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://chris-taylor.github.io/blog/2013/02/09/io-is-not-a-side-effect/&quot;&gt;IO is pure&lt;/a&gt; - Chris Taylor&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.microsoft.com/en-us/research/wp-content/uploads/1993/01/imperative.pdf&quot;&gt;Imperative functional programming&lt;/a&gt; - Simon L. Peyton Jones, Philip Wadler&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.jle.im/entry/first-class-statements&quot;&gt;First-Class “Statements”&lt;/a&gt; - Justin Le&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mónada-estado&quot;&gt;Mónada estado&lt;/h3&gt;
&lt;p&gt;En ocasiones necesitamos que nuestras funciones conserven un estado
además de realizar sus operaciones. Para esos casos existe la mónada
estado &lt;code class=&quot;highlighter-rouge&quot;&gt;State s&lt;/code&gt;, que guarda un valor de estado de tipo &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;. Podemos
pensar en &lt;code class=&quot;highlighter-rouge&quot;&gt;State s a&lt;/code&gt; como &lt;code class=&quot;highlighter-rouge&quot;&gt;s -&amp;gt; (a,s)&lt;/code&gt;; es decir, un elemento dentro
de la mónada es una función dispuesta a tomar un estado inicial y a
devolver algún elemento junto a un estado final.&lt;/p&gt;

&lt;p&gt;Existen tutoriales sobre la mónada estado en:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.haskell.org/State_Monad&quot;&gt;State Monad - Haskell wiki&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://learnyouahaskell.com/for-a-few-monads-more&quot;&gt;For a few monads more - Learn you a Haskell&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://brandon.si/code/the-state-monad-a-tutorial-for-the-confused/&quot;&gt;The State Monad: a tutorial for the confused - Brandon Simmons&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://adit.io/posts/2013-06-10-three-useful-monads.html&quot;&gt;Three useful monads - Aditya Bhargava&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Un uso de la mónada estado puede ser el guardar la semilla de una
generación pseudoaleatoria de números usando
&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_congruential_generator&quot;&gt;generadores lineales congruenciales&lt;/a&gt;.
En concreto, usaremos la fórmula iterativa &lt;script type=&quot;math/tex&quot;&gt;x_{i+1} \equiv 16807x_i \text{ mod } 2147483647&lt;/script&gt;, 
que se expone
&lt;a href=&quot;https://math.dartmouth.edu/archive/m20f11/public_html/RANDOMNESS_LCG.pdf&quot;&gt;aquí&lt;/a&gt;.
Con este generador podremos escribir dados de un número dado de caras
y llamarlos varias veces. El estado interno pasará la semilla
aleatoria de un dado al siguiente:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Control.Monad.State&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Seed&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;dice&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Seed&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;dice&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;16807&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2147483647&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Y podríamos llamarlo con la semilla &lt;code class=&quot;highlighter-rouge&quot;&gt;1000&lt;/code&gt; de la forma siguiente;
que nos devolverá por un lado el resultado de la tirada y por
otro lado la nueva semilla:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;λ&amp;gt; runState (dice 6) 1000
(5,1660)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Si queremos hacer varias tiradas seguidas, podemos usar 
&lt;code class=&quot;highlighter-rouge&quot;&gt;replicateM :: Int -&amp;gt; m a -&amp;gt; m [a]&lt;/code&gt;, que se encarga de pasar 
internamente la semilla de cada tirada a la siguiente tirada:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;λ&amp;gt; fst (runState (replicateM 100 (dice 6)) 1037)

[6,6,2,5,4,3,6,1,4,6,3,6,4,4,6,3,5,1,5,2,6,4,2,6,4,2,4,
5,1,6,5,4,1,3,5,4,6,4,2,3,4,2,1,1,6,5,5,4,1,1,4,6,5,3,6,
3,1,1,5,1,4,1,2,3,5,5,4,5,3,3,2,6,4,1,1,1,2,5,4,5,2,4,5,
6,1,2,4,3,3,6,4,6,3,4,5,1,4,2,2,2]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Incluso podemos crear nuevos generadores aleatorios a partir de los 
anteriores con las operaciones usuales:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;twodices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;State&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Seed&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Int&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;twodices&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;do&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dice&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dice&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Cuando lo llamemos, tomará la distribución suma de las dos distribuciones 
de dados:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;λ&amp;gt; fst (runState (replicateM 100 twodices) 1032)

[8,11,8,8,5,3,7,8,9,5,2,6,7,9,8,7,5,9,3,9,10,7,7,10,
8,2,5,6,4,10,8,6,4,6,4,8,9,7,12,11,9,3,2,7,5,5,6,10,
6,6,3,11,4,7,3,6,3,7,10,4,4,11,4,10,3,5,2,8,4,10,12,
8,9,5,9,11,6,4,10,6,6,12,5,2,7,8,7,4,4,4,9,6,6,6,3,
11,11,9,7,6]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;mónadas-en-teoría-de-categorías&quot;&gt;Mónadas en teoría de categorías&lt;/h2&gt;
&lt;p&gt;Para entender cómo funcionan las 
&lt;a href=&quot;https://es.wikipedia.org/wiki/M%C3%B3nada_(teor%C3%ADa_de_categor%C3%ADas)&quot;&gt;mónadas&lt;/a&gt; 
en teoría de categorías tenemos que entender dos conceptos: los 
&lt;em&gt;productos en una &lt;a href=&quot;https://es.wikipedia.org/wiki/Categor%C3%ADa_monoidal&quot;&gt;categoría monoidal&lt;/a&gt;&lt;/em&gt; y 
&lt;em&gt;los endofuntores de una categoría&lt;/em&gt;. La unión de ambos conceptos es lo que nos dará las mónadas 
como una construcción en teoría de categorías.&lt;/p&gt;

&lt;h3 id=&quot;categorías-monoidales&quot;&gt;Categorías monoidales&lt;/h3&gt;
&lt;p&gt;Simplificando, una categoría monoidal es aquella donde, dados dos objetos &lt;script type=&quot;math/tex&quot;&gt;A,B&lt;/script&gt;, tenemos
un objeto &lt;em&gt;“producto tensor”&lt;/em&gt; de ambos, &lt;script type=&quot;math/tex&quot;&gt;A \otimes B&lt;/script&gt;, donde además existe un objeto identidad &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt;
cumpliendo propiedades como:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \otimes B \cong B \otimes A&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \otimes (B \otimes C) \cong (A \otimes B) \otimes C&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \otimes I \cong A&lt;/script&gt;

&lt;h3 id=&quot;ejemplos-de-categorías-monoidales&quot;&gt;Ejemplos de categorías monoidales&lt;/h3&gt;
&lt;p&gt;Los &lt;strong&gt;conjuntos&lt;/strong&gt; con el producto cartesiano y el conjunto de un elemento forman ya una categoría
monoidal. Puede comprobarse sobre ellos que existen los isomorfismos:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \times B \cong B \times A&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \times (B \times C) \cong (A \times B) \times C&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \times \{\bullet\} \cong A&lt;/script&gt;

&lt;p&gt;Pero además, podemos darles &lt;em&gt;otra&lt;/em&gt; estructura de categoría monoidal, esta vez con la 
&lt;a href=&quot;https://es.wikipedia.org/wiki/Uni%C3%B3n_disjunta&quot;&gt;unión disjunta&lt;/a&gt; y el conjunto vacío:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \sqcup B \cong B \sqcup A&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \sqcup (B \sqcup C) \cong (A \sqcup B) \sqcup C&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \sqcup \varnothing \cong A&lt;/script&gt;

&lt;p&gt;En general, &lt;strong&gt;todas las categorías con productos finitos son
categorías monoidales&lt;/strong&gt; con el producto categórico y el objeto
terminal como unidad. Todas las categorías con coproductos finitos son
categorías monoidales con el coproducto categórico y el objeto inicial
como unidad.&lt;/p&gt;

&lt;p&gt;Otro ejemplo distinto lo forman los &lt;strong&gt;espacios vectoriales&lt;/strong&gt; sobre un
cuerpo &lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt; con el producto tensor y el propio cuerpo sirviendo como
unidad; o los &lt;strong&gt;grupos abelianos&lt;/strong&gt; con el producto tensor y
&lt;script type=&quot;math/tex&quot;&gt;\mathbb{Z}&lt;/script&gt; siendo la unidad.&lt;/p&gt;

&lt;h3 id=&quot;objetos-monoide&quot;&gt;Objetos monoide&lt;/h3&gt;
&lt;p&gt;Un objeto &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; de una categoría monoidal es objeto monoide cuando puedo
definir un morfismo desde el objeto identidad hacia él y un morfismo
desde el producto tensor &lt;script type=&quot;math/tex&quot;&gt;A \otimes A&lt;/script&gt; hacia él. Es decir, hay un
morfismo &lt;em&gt;cero&lt;/em&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;I \overset{0}\longrightarrow A&lt;/script&gt;

&lt;p&gt;Y un morfismo &lt;em&gt;multiplicación&lt;/em&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A \otimes A \overset{\mu}\longrightarrow A&lt;/script&gt;

&lt;p&gt;Cumpliendo ciertas propiedades similares a las que exigimos a un
monoide. De hecho, un objeto monoide en la categoría de los conjuntos
con el producto cartesiano es simplemente un &lt;strong&gt;monoide&lt;/strong&gt; normal y
corriente.&lt;/p&gt;

&lt;h3 id=&quot;categorías-de-endofuntores&quot;&gt;Categorías de endofuntores&lt;/h3&gt;
&lt;p&gt;El ejemplo que nos interesa ahora, sin embargo, es el de los
&lt;strong&gt;endofuntores&lt;/strong&gt; de una categoría.  Un &lt;strong&gt;funtor&lt;/strong&gt;, de forma
simplificada, es una &lt;em&gt;aplicación entre categorías&lt;/em&gt;; que lleva objetos
en objetos y morfismos en morfismos, respetando además el punto de
inicio y fin de cada morfismo.&lt;/p&gt;

&lt;p&gt;Si consideramos los funtores de una categoría a sí misma, tenemos los
&lt;strong&gt;endofuntores&lt;/strong&gt; de la categoría. Y entre ellos existen
transformaciones naturales que actúan como morfismos en el sentido de
que se componen para dar otras transformaciones naturales. Teniendo
unos objetos (los endofuntores), y unos morfismos (las
transformaciones naturales), tenemos una categoría. Nótese que hemos
abstraído mucho, estamos trabajando con una categoría en la que cada
objeto es en sí mismo un endofuntor y cada morfismo es toda una
transformación natural entre dos funtores.&lt;/p&gt;

&lt;p&gt;Esta es además una categoría monoidal. El producto tensor de esta
categoría monoidal será la composición &lt;script type=&quot;math/tex&quot;&gt;\circ&lt;/script&gt;, y el objeto identidad
el endofuntor identidad, que actúa dejando fijo cada objeto y cada
morfismo.&lt;/p&gt;

&lt;h3 id=&quot;mónadas&quot;&gt;Mónadas&lt;/h3&gt;
&lt;p&gt;Pues bien, una mónada es un objeto monoide en la categoría de los
endofuntores con la composición como producto tensor. Esto quiere
decir que es un endofuntor &lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt; con transformaciones naturales:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F \circ F \Rightarrow F&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;I \Rightarrow F&lt;/script&gt;

&lt;p&gt;Como una transformación natural nos da un morfismo por cada objeto en
el que se aplica el funtor, lo que tenemos son familias de morfismos:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;F(F(X)) \overset{\mu_x}\longrightarrow F(X)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;X \overset{r_x}\longrightarrow F(X)&lt;/script&gt;

&lt;h3 id=&quot;una-categoría-para-la-programación-funcional&quot;&gt;Una categoría para la programación funcional&lt;/h3&gt;
&lt;p&gt;Algunos sistemas de tipos, con las funciones entre ellos &lt;code class=&quot;highlighter-rouge&quot;&gt;A -&amp;gt; B&lt;/code&gt; como
morfismos, forman una categoría&lt;sup id=&quot;fnref:computational-trinitarianism&quot;&gt;&lt;a href=&quot;#fn:computational-trinitarianism&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;. No es
el caso de Haskell, en el que, por varios motivos, sus tipos no forman
una categoría&lt;sup id=&quot;fnref:hask-not-a-category&quot;&gt;&lt;a href=&quot;#fn:hask-not-a-category&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;; pero las construcciones con
inspiración en la teoría de categorías toman el nombre de sus
homólogas.&lt;sup id=&quot;fnref:hask-matters&quot;&gt;&lt;a href=&quot;#fn:hask-matters&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;El primer ejemplo de esto son los &lt;strong&gt;funtores&lt;/strong&gt;. En Haskell, un funtor
se define como:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;Functor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;where&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Es decir un funtor toma un tipo &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt; (un objeto de la categoría), y nos
devuelve otro tipo &lt;code class=&quot;highlighter-rouge&quot;&gt;f a&lt;/code&gt; (otro objeto de la &lt;em&gt;misma&lt;/em&gt; categoría). Por
otro lado, el funtor toma un morfismo &lt;code class=&quot;highlighter-rouge&quot;&gt;a -&amp;gt; b&lt;/code&gt; y nos devuelve otro
morfismo &lt;code class=&quot;highlighter-rouge&quot;&gt;f a -&amp;gt; f b&lt;/code&gt;. Es decir, los funtores de la programación
funcional son &lt;strong&gt;endofuntores en la categoría de los tipos&lt;/strong&gt;, siempre
que conserven ciertas reglas que tienen su reflejo en las reglas de
funtores en Haskell.&lt;/p&gt;

&lt;h3 id=&quot;monoides-en-la-categoría-de-los-endofuntores&quot;&gt;Monoides en la categoría de los endofuntores&lt;/h3&gt;

&lt;p&gt;Entonces, si los funtores &lt;code class=&quot;highlighter-rouge&quot;&gt;f :: * -&amp;gt; *&lt;/code&gt; son endofuntores en alguna
categoría, tiene sentido cuestionarse cuáles de ellos son
monoides. Esto, junto con ciertas restricciones que se le imponen como
leyes a las mónadas, equivale a decir que existen los morfismos dados
por las transformaciones naturales que pedíamos antes, es decir, deben
existir morfismos de tipos &lt;code class=&quot;highlighter-rouge&quot;&gt;a -&amp;gt; m a&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;m (m a) -&amp;gt; m a&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Así, a cualquier funtor que tiene estos dos morfismos, además del
&lt;code class=&quot;highlighter-rouge&quot;&gt;fmap&lt;/code&gt; que tenía por ser funtor, lo llamamos &lt;strong&gt;mónada&lt;/strong&gt;. Nótese que
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt;=&lt;/code&gt; puede implementarse desde &lt;code class=&quot;highlighter-rouge&quot;&gt;join&lt;/code&gt; y viceversa, como:&lt;/p&gt;

&lt;div class=&quot;language-haskell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fmap&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Tenemos entonces dos definiciones equivalentes de lo que es una
mónada. Una desde la teoría de categorías y otra desde la teoría de
tipos y los lenguajes de programación funcional. Una visión desde 
las mónadas como monoides en la categoría de los endofuntores
desde dentro de Haskell puede verse 
&lt;a href=&quot;http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html&quot;&gt;aquí&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;y-más&quot;&gt;Y más&lt;/h2&gt;
&lt;p&gt;Además de las enunciadas en este post, existen más otros temas
relevantes en relación a las mónadas, tanto en programación funcional
como en teoría de categorías:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://book.realworldhaskell.org/read/monad-transformers.html&quot;&gt;Transformadores de mónadas&lt;/a&gt;, usadas para componer mónadas.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://stackoverflow.com/questions/8428554/what-is-the-comonad-typeclass-in-haskell&quot;&gt;Comónadas&lt;/a&gt;, la noción dual de una mónada.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Kleisli_category&quot;&gt;Categorías de Kleisli&lt;/a&gt;, cada mónada da lugar a una categoría de Kleisli.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Adjoint_functors&quot;&gt;Funtores adjuntos&lt;/a&gt;, cada par de funtores adjuntos da lugar a una mónada.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.cs.tufts.edu/comp/150FP/archive/brent-yorgey/tc.pdf&quot;&gt;Typeclassopedia&lt;/a&gt;, una revisión de otras clases de tipos relevantes en Haskell y relacionadas con la teoría de categorías.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;referencias&quot;&gt;Referencias&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:do-notation-harmful&quot;&gt;
      &lt;p&gt;Peligros de la notación do. &lt;a href=&quot;https://wiki.haskell.org/Do_notation_considered_harmful&quot;&gt;Do notation considered harmful&lt;/a&gt; &lt;a href=&quot;#fnref:do-notation-harmful&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:fpearls-rationals&quot;&gt;
      &lt;p&gt;Enumerando los racionales. &lt;a href=&quot;http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/rationals.pdf&quot;&gt;Enumerating the rationals - J. Gibbons, D. Lester, R. Bird&lt;/a&gt; &lt;a href=&quot;#fnref:fpearls-rationals&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:computational-trinitarianism&quot;&gt;
      &lt;p&gt;La correspondencia entre tipos, lógica y categorías. &lt;a href=&quot;https://ncatlab.org/nlab/show/computational+trinitarianism&quot;&gt;Computational Trinitarianism - NLab&lt;/a&gt; &lt;a href=&quot;#fnref:computational-trinitarianism&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:hask-not-a-category&quot;&gt;
      &lt;p&gt;Por qué los tipos de Haskell no son una categoría. &lt;a href=&quot;http://math.andrej.com/2016/08/06/hask-is-not-a-category/&quot;&gt;Hask is not a category - Andrej Bauer&lt;/a&gt; &lt;a href=&quot;#fnref:hask-not-a-category&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:hask-matters&quot;&gt;
      &lt;p&gt;Por qué en ocasiones puede ser útil pensar en ellos como una categoría. &lt;a href=&quot;https://ro-che.info/articles/2016-08-07-hask-category&quot;&gt;Does it matter if Hask is (not) a category?&lt;/a&gt; &lt;a href=&quot;#fnref:hask-matters&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
            <pubDate>Wed, 21 Dec 2016 00:00:00 +0000</pubDate>
            <link>/blog/2016/12/21/monadas/</link>
            <guid isPermaLink="true">/blog/2016/12/21/monadas/</guid>
        </item>
        
        <item>
            <title>Apuntes para el doble grado</title>
            <description>&lt;h2 id=&quot;repositorio-de-apuntes&quot;&gt;Repositorio de apuntes&lt;/h2&gt;

&lt;p&gt;A iniciativa de los alumnos de segundo, hemos dejado público un repositorio de
apuntes colectivo sobre las asignaturas del doble grado:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/apuntesDGIIM/&quot;&gt;ApuntesDGIIM - GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Puedes descargar los apuntes, todavía en construcción, y con licencia Creative Commons en su
&lt;a href=&quot;/apuntesDGIIM/&quot;&gt;página&lt;/a&gt;, que estará disponible desde
&lt;a href=&quot;/recursos&quot;&gt;recursos&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Sun, 16 Oct 2016 00:00:00 +0000</pubDate>
            <link>/blog/2016/10/16/apuntes/</link>
            <guid isPermaLink="true">/blog/2016/10/16/apuntes/</guid>
        </item>
        
        <item>
            <title>Aprendiendo Emacs</title>
            <description>&lt;h2 id=&quot;emacs&quot;&gt;Emacs&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;&lt;strong&gt;Emacs&lt;/strong&gt;&lt;/a&gt; es un editor de texto
construido sobre un intérprete del lenguaje
&lt;a href=&quot;https://es.wikipedia.org/wiki/Emacs_Lisp&quot;&gt;&lt;strong&gt;Elisp&lt;/strong&gt;&lt;/a&gt; para hacerlo extensible. Cada acción
del editor constituye un comando sobre el intérprete, por lo que podemos reescribir sus
comandos o crear nuevos comandos simplemente programando sobre el intérprete.&lt;/p&gt;

&lt;figure class=&quot;fig med&quot;&gt;
  &lt;a href=&quot;/assets/images/blog/emacs.png&quot; title=&quot;Ver imagen completa&quot;&gt;
    &lt;img src=&quot;/assets/images/blog/emacs.png&quot; /&gt;
  &lt;/a&gt;
  Emacs editando este mismo artículo
&lt;/figure&gt;

&lt;p&gt;Emacs sirve como IDE para la mayoría de lenguajes de programación, como
editor para programación literaria y ciencia reproducible; se integra con git y
con el sistema de archivos, y tiene extensiones disponibles para usarse como
aplicación para organizar listas de tareas, leer el correo o servir como hoja
de cálculo.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I use Emacs, which might be thought of as a thermonuclear word processor.&lt;/p&gt;

  &lt;p&gt;– &lt;strong&gt;Neal Stephenson&lt;/strong&gt;, &lt;em&gt;In the Beginning… was the command line.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;En este artículo haré una referencia breve a todo lo que me ha ido sirviendo
para aprender Emacs mientras enlazo a fuentes que tratan cada uno de los temas
más extensamente. Como recursos generales para aprender Emacs, puedo recomendar:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PLxj9UAX4Em-IiOfvF2Qs742LxEK4owSkr&quot;&gt;&lt;strong&gt;.Emacs Tutorials&lt;/strong&gt;&lt;/a&gt;
de &lt;em&gt;jekor&lt;/em&gt;, explican todo lo necesario para aprender
Emacs en 10 videotutoriales que pueden seguirse progresivamente.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/playlist?list=PL8tzorAO7s0he-pp7Y_JDl7-Kz2Qlr_Pj&quot;&gt;&lt;strong&gt;Emacs Meetups&lt;/strong&gt;&lt;/a&gt;
de Thoughtbot, que profundizan sobre temas concretos de uso
de Emacs.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://emacsrocks.com/&quot;&gt;&lt;strong&gt;Emacs Rocks&lt;/strong&gt;&lt;/a&gt;, vídeos breves sobre casos concretos de uso de Emacs.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.emacswiki.org/emacs/SiteMap&quot;&gt;&lt;strong&gt;Emacs wiki&lt;/strong&gt;&lt;/a&gt;, una wiki que documenta
todo lo relacionado con Emacs.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sachachua.com/blog/category/geek/emacs/&quot;&gt;&lt;strong&gt;sachachua.com&lt;/strong&gt;&lt;/a&gt;,
donde se hace referencia periódicamente a noticias
de Emacs, y tiene escritas hojas de referencia de atajos de teclado de Emacs.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://cestlaz.github.io/stories/emacs/&quot;&gt;&lt;strong&gt;C’est la z&lt;/strong&gt;&lt;/a&gt;, otro blog en el que se tratan temas relacionados con Emacs.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/&quot;&gt;&lt;strong&gt;GNU Emacs&lt;/strong&gt;&lt;/a&gt;, la documentación oficial de Emacs.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://elbauldelprogramador.com/chuleta-atajos-teclado-emacs/&quot;&gt;&lt;strong&gt;El baúl del programador&lt;/strong&gt;&lt;/a&gt; ha empeazado
una recopilación colaborativa de los comandos y paquetes más útiles para Emacs.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;instalación&quot;&gt;Instalación&lt;/h3&gt;

&lt;p&gt;Emacs puede encontrarse en la mayoría de gestores de paquetes, pero puede no
estar en su versión más actualizada.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt install emacs
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Para escribir este artículo estoy usando &lt;code class=&quot;highlighter-rouge&quot;&gt;GNU Emacs 25.1&lt;/code&gt;, pero la última
versión estable es la &lt;strong&gt;24.5&lt;/strong&gt;. La versión estable actual puede descargarse desde
&lt;a href=&quot;https://www.gnu.org/software/emacs/&quot;&gt;GNU&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;atajos-de-teclado&quot;&gt;Atajos de teclado&lt;/h2&gt;

&lt;p&gt;En Emacs se usa una &lt;a href=&quot;https://www.emacswiki.org/emacs/EmacsKeyNotation&quot;&gt;notación específica&lt;/a&gt;
para escribir un atajos de teclado.
La mayoría de documentación que consultes usará &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x&lt;/code&gt; en lugar de &lt;code class=&quot;highlighter-rouge&quot;&gt;Control+x&lt;/code&gt;;
usará &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x C-s&lt;/code&gt; para indicar que debes dejar pulsado &lt;code class=&quot;highlighter-rouge&quot;&gt;Control&lt;/code&gt; mientras pulsas
&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt;;
y por último, usará &lt;code class=&quot;highlighter-rouge&quot;&gt;M-x&lt;/code&gt;, donde la &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; se referirá a la tecla &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt;.
La tecla &lt;code class=&quot;highlighter-rouge&quot;&gt;Meta&lt;/code&gt; en Emacs se refiere normalmente a
dos opciones equivalentes, o bien pulsar &lt;code class=&quot;highlighter-rouge&quot;&gt;alt izq.&lt;/code&gt; mientras se pulsa &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, o pulsar &lt;code class=&quot;highlighter-rouge&quot;&gt;Esc&lt;/code&gt; y luego pulsar
&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;. En resumen:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Atajo&lt;/th&gt;
      &lt;th&gt;Descripción&lt;/th&gt;
      &lt;th&gt;Comando&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;C-n&lt;/td&gt;
      &lt;td&gt;Mantener control pulsado mientras se pulsa n&lt;/td&gt;
      &lt;td&gt;Next line&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;C-x C-s&lt;/td&gt;
      &lt;td&gt;Mantener control pulsado pulsando x y luego s&lt;/td&gt;
      &lt;td&gt;Save file&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;M-x&lt;/td&gt;
      &lt;td&gt;Mantener alt o pulsar esc para luego pulsar x&lt;/td&gt;
      &lt;td&gt;Execute Command&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;RET&lt;/td&gt;
      &lt;td&gt;Salto de línea, pulsar enter antes de seguir&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Usar atajos de teclado facilita mucho usar Emacs rápidamente después del tiempo
de aprendizaje. &lt;sup id=&quot;fnref:emacs-productivo&quot;&gt;&lt;a href=&quot;#fn:emacs-productivo&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;Cuando abras el programa por primera vez, te ofrecerá seguir un tutorial de Emacs
escrito en Emacs. El tutorial es muy útil para aprender a moverse dentro de
Emacs, pero la mayoría de lo que cuenta no es especialmente fácil de aprender
de una sola vez. Lo más chocante para un usuario nuevo puede ser el sistema de copiar-pegar;
que de forma muy simplificada se resume en: &lt;sup id=&quot;fnref:emacs-kill-buffer&quot;&gt;&lt;a href=&quot;#fn:emacs-kill-buffer&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;M-w&lt;/code&gt; copia.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-w&lt;/code&gt; corta.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-y&lt;/code&gt; pega.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pero si no te convence, puedes usar &lt;a href=&quot;https://www.emacswiki.org/emacs/CuaMode&quot;&gt;CUA Mode&lt;/a&gt;,
que te permite volver a usar &lt;code class=&quot;highlighter-rouge&quot;&gt;C-c&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;C-v&lt;/code&gt; para copiar y pegar.
Otros comandos útiles de aprender antes de empezar con nada más son &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x C-s&lt;/code&gt; para
guardar y &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x C-f&lt;/code&gt; para abrir un archivo.&lt;/p&gt;

&lt;h3 id=&quot;documentación&quot;&gt;Documentación&lt;/h3&gt;

&lt;p&gt;Emacs es un editor autodocumentado, es decir, la documentación del editor puede consultarse
dentro del propio programa. Para llamar a la ayuda se puede pulsar &lt;code class=&quot;highlighter-rouge&quot;&gt;C-h ?&lt;/code&gt;, que nos
dejará elegir si necesitamos ayuda sobre comandos, atajos de teclados, variables,
licencias, etc. Especialmente útiles son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-h c &amp;lt;atajo de teclado&amp;gt;&lt;/code&gt; nos da el nombre de la función que se ejecuta al pulsar
esas teclas.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;C-h f &amp;lt;nombre de función&amp;gt;&lt;/code&gt; documenta la función.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;buffers-y-ventanas&quot;&gt;Buffers y ventanas&lt;/h3&gt;

&lt;p&gt;Cada vez que abrimos un archivo, o pedimos un apartado de documentación, o abrimos
la configuración, se abre un nuevo buffer. Un &lt;a href=&quot;https://www.emacswiki.org/emacs/Buffer&quot;&gt;buffer&lt;/a&gt;
es el equivalente a un documento
o un espacio de trabajo en otros editores Podemos movernos entre los buffers
actualmente abiertos pulsando &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x &amp;lt;left&amp;gt;&lt;/code&gt; o &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x &amp;lt;right&amp;gt;&lt;/code&gt;; y podemos mostrar la
lista de buffers actualmente abiertos con &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x C-b&lt;/code&gt; (¡en un nuevo buffer!).&lt;/p&gt;

&lt;p&gt;Además de los buffers que tengamos actualmente abiertos, tenemos ventanas que los
muestran. Podemos partir la pantalla de Emacs en varias ventanas con &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x 2&lt;/code&gt; y
&lt;code class=&quot;highlighter-rouge&quot;&gt;C-x 3&lt;/code&gt;, que la parten horizontal y verticalmente respectivamente. Para volver a
quedarnos sólo con la ventana en la que está el cursor, podemos pulsar &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x 1&lt;/code&gt;;
y para cambiar de ventana sobre la que actúa el cursor podemos usar &lt;code class=&quot;highlighter-rouge&quot;&gt;C-x o&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;modos-de-emacs&quot;&gt;Modos de Emacs&lt;/h3&gt;

&lt;p&gt;El comportamiento de Emacs sobre cada buffer que abra será distinto dependiendo
normalmente de la extensión del archivo. Esto le permite colorear de manera distinta
distintas sintaxis, o tener comportamientos específicos (indentación, atajos de teclado,
formateo) cuando está editando cada lenguaje.&lt;/p&gt;

&lt;p&gt;Cada una de estas formas de edición se llama
&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Major-Modes.html&quot;&gt;&lt;strong&gt;modo&lt;/strong&gt;&lt;/a&gt;,
y el &lt;strong&gt;modo&lt;/strong&gt; actual aparece
resaltado entre paréntesis en la barra inferior de Emacs. El modo básico es &lt;code class=&quot;highlighter-rouge&quot;&gt;Fundamental&lt;/code&gt;,
pero para cada propósito existen modos específicos. Para casi todos los lenguajes de programación
tendremos un modo. Existen, por ejemplo,
&lt;a href=&quot;https://www.emacswiki.org/emacs/RubyMode&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Ruby-mode&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://www.emacswiki.org/emacs?action=browse;oldid=PythonMode;id=PythonProgrammingInEmacs#toc2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Python-mode&lt;/code&gt;&lt;/a&gt;
o &lt;a href=&quot;https://www.emacswiki.org/emacs/CcMode&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CC-mode&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Además de los &lt;em&gt;modos mayores&lt;/em&gt;
de los que hemos hablado hasta ahora, existen &lt;em&gt;modos menores&lt;/em&gt; que son opcionales
y complementan a los modos mayores.
Por ejemplo, mientras escribo este artículo estoy usando
&lt;a href=&quot;https://www.emacswiki.org/emacs/MarkdownMode&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Markdown&lt;/code&gt;&lt;/a&gt; como modo mayor
y &lt;code class=&quot;highlighter-rouge&quot;&gt;ARev&lt;/code&gt; (&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Reverting.html&quot;&gt;Auto-revert mode&lt;/a&gt;)
como modo menor.&lt;/p&gt;

&lt;h2 id=&quot;personalización&quot;&gt;Personalización&lt;/h2&gt;

&lt;p&gt;Prácticamente todos los parámetros que uses en Emacs pueden ser ajustados a tu
necesidad. Desde los atajos de teclado hasta el tema de color y fuentes que usa el editor.&lt;/p&gt;

&lt;p&gt;La forma más básica de editar todas estas configuraciones es &lt;code class=&quot;highlighter-rouge&quot;&gt;M-x customize group&lt;/code&gt;,
que accede a un menú en el que se pueden modificar todas ellas. Todos los cambios
que aquí se hagan se guardarán en un archivo &lt;code class=&quot;highlighter-rouge&quot;&gt;.emacs&lt;/code&gt; (o &lt;code class=&quot;highlighter-rouge&quot;&gt;init.el&lt;/code&gt;, en las versiones
nuevas de Emacs). Este archivo es la otra forma de configurar Emacs; el archivo de inicio
&lt;code class=&quot;highlighter-rouge&quot;&gt;.emacs&lt;/code&gt; contiene código en Elisp que se ejecutará al iniciar el editor y podemos incluir
allí todo lo que queramos configurar. Algunos
paquetes, por ejemplo, necesitarán configuración adicional que habrá que incluir en este archivo.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/mMcc0IF1hV0&quot;&gt;&lt;strong&gt;.Emacs #2 - Customizations and themes&lt;/strong&gt; - &lt;em&gt;jekor&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;sistemas-de-paquetes&quot;&gt;Sistemas de paquetes&lt;/h2&gt;

&lt;h3 id=&quot;melpa&quot;&gt;Melpa&lt;/h3&gt;
&lt;p&gt;Es conveniente añadir un repositorio más grande que el que trae GNU por defecto, y
&lt;a href=&quot;https://melpa.org/#/&quot;&gt;MELPA&lt;/a&gt; es uno de los repositorios de paquetes de Emacs más
grandes y actualizados.
El repositorio de MELPA se añade desde &lt;code class=&quot;highlighter-rouge&quot;&gt;M-x customize-group RET package&lt;/code&gt;. Dentro
de la pestaña de repositorios puede insertarse la dirección de MELPA:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Archive name: melpa-stable
 URL or directory name: https://stable.melpa.org/packages/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Para salir de cualquiera de las pantallas de personalización se usa &lt;code class=&quot;highlighter-rouge&quot;&gt;q&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Otra forma de conseguir este mismo efecto es añadirlo directamente a nuestro
archivo de configuración (&lt;code class=&quot;highlighter-rouge&quot;&gt;.emacs&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;init.el&lt;/code&gt;), como se indica en las &lt;a href=&quot;https://melpa.org/packages/&quot;&gt;instrucciones
de instalación&lt;/a&gt; del repositorio.&lt;/p&gt;

&lt;h3 id=&quot;paquetes&quot;&gt;Paquetes&lt;/h3&gt;

&lt;p&gt;Podemos listar los paquetes que podemos instalar usado &lt;code class=&quot;highlighter-rouge&quot;&gt;M-x list-packages&lt;/code&gt; y podemos
buscar entre los paquetes pulsando varias veces el comando &lt;code class=&quot;highlighter-rouge&quot;&gt;C-s&lt;/code&gt;. Si pulsamos &lt;code class=&quot;highlighter-rouge&quot;&gt;i&lt;/code&gt; al lado
de uno de ellos se marcará para instalar y al pulsar &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; se ejecutará la instalación de
todos los paquetes marcados.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/Cf6tRBPbWKs&quot;&gt;&lt;strong&gt;.Emacs #3 - Installing packages and extensions&lt;/strong&gt; - &lt;em&gt;jekor&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;paquetes-útiles&quot;&gt;Paquetes útiles&lt;/h2&gt;

&lt;h3 id=&quot;dired&quot;&gt;Dired&lt;/h3&gt;

&lt;p&gt;Dired viene instalado por defecto con Emacs y permite navegar la estructura de
directorios del sistema operativo. Podemos empezar a navegarla usando &lt;code class=&quot;highlighter-rouge&quot;&gt;M-x dired&lt;/code&gt; y
pulsando &lt;code class=&quot;highlighter-rouge&quot;&gt;RET&lt;/code&gt; cada vez que queramos abrir un archivo o una carpeta.&lt;/p&gt;

&lt;p&gt;Podemos además afectar a los archivos. Por ejemplo, si queremos eliminar algunos
archivos, podemos marcarlos con &lt;code class=&quot;highlighter-rouge&quot;&gt;d&lt;/code&gt; y eliminarlos definitivamente con &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/7jZdul2fC94&quot;&gt;&lt;strong&gt;.Emacs #4 - Exploring the filesystem&lt;/strong&gt; - &lt;em&gt;jekor&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;org-mode&quot;&gt;org-mode&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;org-mode&lt;/strong&gt; es un modo de Emacs que se creó
originalmente para gestionar listas de tareas, agendas y calendarios; pero además,
contiene en su interior un completo lenguaje de marcado. Permite exportar
documentos a una gran variedad de formatos (pdf, html, latex o markdown) e incluir
internamente trozos de código y ejecutarlos. Además, tiene
un sistema de tablas en texto plano capaz de sustituir la hoja de cálculo para tareas
sencillas. Por todo esto, puede ser usado en tareas como la ciencia reproducible o la
programación literaria cuando Latex es demasiado complejo, ayudando además a manejar
la bibliografía y los enlaces tanto externos como entre archivos.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/SzA2YODtgK4&quot;&gt;&lt;strong&gt;Getting started with org-mode&lt;/strong&gt; - &lt;em&gt;Harry Schwartz&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Especialmente útil para matemáticas es la
&lt;a href=&quot;http://orgmode.org/worg/org-tutorials/org-latex-preview.html&quot;&gt;previsualización de Latex&lt;/a&gt;
y el poder incluir los paquetes de la &lt;a href=&quot;ftp://ftp.ams.org/pub/tex/doc/amsmath/amsldoc.pdf&quot;&gt;AMS&lt;/a&gt;
para marcar teoremas o definiciones.&lt;/p&gt;

&lt;figure class=&quot;fig med&quot;&gt;
  &lt;a href=&quot;/assets/images/blog/org-math.png&quot; title=&quot;Ver imagen completa&quot;&gt;
    &lt;img src=&quot;/assets/images/blog/org-math.png&quot; /&gt;
  &lt;/a&gt;
  Apuntes de matemáticas en org-mode
&lt;/figure&gt;

&lt;h3 id=&quot;magit&quot;&gt;magit&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;magit&lt;/strong&gt; permite integrar Emacs con &lt;strong&gt;git&lt;/strong&gt; fácilmente para incluir los commits desde
dentro del mismo editor. Usando &lt;code class=&quot;highlighter-rouge&quot;&gt;magit-status&lt;/code&gt; llegamos a una pantalla en la que podemos
elegir qué ficheros añadir al commit con &lt;code class=&quot;highlighter-rouge&quot;&gt;s&lt;/code&gt; &lt;sup id=&quot;fnref:magit-select&quot;&gt;&lt;a href=&quot;#fn:magit-select&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; y visualizar las diferencias con el commit
anterior usando &lt;code class=&quot;highlighter-rouge&quot;&gt;tab&lt;/code&gt;; ejecutar el commit con &lt;code class=&quot;highlighter-rouge&quot;&gt;c c&lt;/code&gt;, que nos mostrará
el buffer con el mensaje de commit y por último usar &lt;code class=&quot;highlighter-rouge&quot;&gt;C-c C-c&lt;/code&gt; para enviarlo. El push y
pull los haremos desde &lt;code class=&quot;highlighter-rouge&quot;&gt;magit-status&lt;/code&gt; con &lt;code class=&quot;highlighter-rouge&quot;&gt;P u&lt;/code&gt; y &lt;code class=&quot;highlighter-rouge&quot;&gt;F u&lt;/code&gt;, respectivamente.&lt;/p&gt;

&lt;p&gt;Es útil asignar un atajo de teclado al comando &lt;code class=&quot;highlighter-rouge&quot;&gt;magit-status&lt;/code&gt;, que es el que muestra la
ventana desde la que controlamos el añadir y hacer commit de ficheros. Por ejemplo, podemos
fijarlo en &lt;code class=&quot;highlighter-rouge&quot;&gt;f5&lt;/code&gt; añadiendo a nuestro archivo de configuración:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-lisp&quot;&gt;(global-set-key (kbd &quot;&amp;lt;f5&amp;gt;&quot;) 'magit-status)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;macros-de-teclado&quot;&gt;Macros de teclado&lt;/h2&gt;

&lt;p&gt;Las macros de teclado nos dejan grabar una secuencia de acciones y volver a repetirla
tantas veces como sea necesaria. Se puede empezar a grabar con &lt;strong&gt;“f3”&lt;/strong&gt; y terminar la
grabación y repetirla tantas veces como sea necesario con &lt;strong&gt;“f4”&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://youtu.be/JfZ9fCHzkJw&quot;&gt;&lt;strong&gt;.Emacs #9 - Keyboard macros&lt;/strong&gt; - &lt;em&gt;jekor&lt;/em&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;elisp&quot;&gt;Elisp&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/elisp/&quot;&gt;Emacs Lisp&lt;/a&gt;, o Elisp, es un
lenguaje de programación diseñado específicamente para escribir un editor de texto.
Facilita el tratamiento de texto y el manejo de archivos y buffers.&lt;/p&gt;

&lt;p&gt;Podemos escribir scripts en Elisp que se encarguen de tareas repetitivas en nuestro editor
de texto y asignarlas a atajos de teclado o ampliarlo con más funcionalidad. Un tutorial
básico sobre Elisp es &lt;a href=&quot;http://emacs-doctor.com/learn-emacs-lisp-in-15-minutes.html&quot;&gt;Learn Emacs Lisp in 15 minutes&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;notas&quot;&gt;Notas&lt;/h2&gt;
&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:emacs-productivo&quot;&gt;
      &lt;p&gt;Realmente solo puedo decir que a mí me funciona y que en general los atajos de teclado parecen ser &lt;a href=&quot;http://ux.stackexchange.com/a/30749&quot;&gt;mejores que usar el ratón&lt;/a&gt;. &lt;a href=&quot;#fnref:emacs-productivo&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:emacs-kill-buffer&quot;&gt;
      &lt;p&gt;El &lt;a href=&quot;https://www.gnu.org/software/emacs/manual/html_node/emacs/Killing.html#Killing&quot;&gt;sistema&lt;/a&gt; que Emacs usa para esto es bastante más sofisticado. &lt;a href=&quot;#fnref:emacs-kill-buffer&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:magit-select&quot;&gt;
      &lt;p&gt;De hecho, podemos seleccionar qué párrafos dentro de un fichero queremos añadir al commit. &lt;a href=&quot;#fnref:magit-select&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</description>
            <pubDate>Mon, 19 Sep 2016 00:00:00 +0000</pubDate>
            <link>/blog/2016/09/19/aprendiendo-emacs/</link>
            <guid isPermaLink="true">/blog/2016/09/19/aprendiendo-emacs/</guid>
        </item>
        
        <item>
            <title>Apuntes de introducción al cálculo</title>
            <description>&lt;p&gt;Presentamos el código fuente de un libro completo de Cálculo escrito por D. Francisco Javier Pérez González, profesor
del departamento de Análisis Matemático de la Universidad de Granada, que sirve como una maravillosa
introducción al Análisis y al razonamiento matemático. Los apuntes están escritos en Latex y licenciados en
Creative Commons BY-NC-SA.&lt;/p&gt;

&lt;p&gt;Queremos agradecérselos a D. Javier Pérez,
que nos proporcionó el código de sus apuntes para que pudiésemos publicarlo, y que ha ayudado a hacer del
conocimiento algo libre y accesible a sus alumnos. En su &lt;a href=&quot;http://www.ugr.es/~fjperez/&quot;&gt;página web&lt;/a&gt;
se puede encontrar mucho más material dedicado al análisis matemático, como series de
Fourier, variable compleja o análisis en &lt;script type=&quot;math/tex&quot;&gt;\mathbb{R}^n&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Está disponible &lt;a href=&quot;https://github.com/libreim/calculo/releases/download/apuntes/calculo.pdf&quot;&gt;el libro completo en formato PDF&lt;/a&gt; y el código fuente lo alojamos en &lt;a href=&quot;https://github.com/libreim/calculo&quot;&gt;este repositorio en GitHub&lt;/a&gt;.&lt;/p&gt;
</description>
            <pubDate>Fri, 22 Jul 2016 00:00:00 +0000</pubDate>
            <link>/blog/2016/07/22/apuntes-de-introduccion-al-calculo/</link>
            <guid isPermaLink="true">/blog/2016/07/22/apuntes-de-introduccion-al-calculo/</guid>
        </item>
        
    </channel>
</rss>
